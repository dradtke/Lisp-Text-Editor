@menu
* about-dialog::
* accel-label::
* alignment::
* arrow::
* aspect-frame::
* assistant::
* bin::
* box::
* button::
* button-box::
* calendar::
* cell-view::
* check-button::
* check-menu-item::
* color-button::
* color-selection::
* color-selection-dialog::
* combo-box::
* combo-box-entry::
* container::
* curve::
* dialog::
* drawing-area::
* entry::
* event-box::
* expander::
* file-chooser-button::
* file-chooser-dialog::
* file-chooser-widget::
* fixed::
* font-button::
* font-selection::
* font-selection-dialog::
* frame::
* gamma-curve::
* gtk-window::
* h-box::
* h-button-box::
* h-paned::
* h-ruler::
* h-s-v::
* h-scale::
* h-scrollbar::
* h-separator::
* handle-box::
* icon-view::
* image::
* image-menu-item::
* input-dialog::
* invisible::
* item::
* label::
* layout::
* link-button::
* menu::
* menu-bar::
* menu-item::
* menu-shell::
* menu-tool-button::
* message-dialog::
* misc::
* notebook::
* page-setup-unix-dialog::
* paned::
* plug::
* print-unix-dialog::
* progress::
* progress-bar::
* radio-button::
* radio-menu-item::
* radio-tool-button::
* range::
* recent-chooser-dialog::
* recent-chooser-menu::
* recent-chooser-widget::
* ruler::
* scale::
* scale-button::
* scrollbar::
* scrolled-window::
* separator::
* separator-menu-item::
* separator-tool-item::
* socket::
* spin-button::
* statusbar::
* table::
* tearoff-menu-item::
* text-view::
* toggle-button::
* toggle-tool-button::
* tool-button::
* tool-item::
* toolbar::
* tree-view::
* v-box::
* v-button-box::
* v-paned::
* v-ruler::
* v-scale::
* v-scrollbar::
* v-separator::
* viewport::
* volume-button::
* widget::
@end menu

@node about-dialog
@section about-dialog
@Class about-dialog
Superclass: @ref{dialog} @ref{atk-implementor-iface} @ref{buildable}

The @ref{about-dialog} offers a simple way to display information about a program like its logo, name, copyright, website and license. It is also possible to give credits to the authors, documenters, translators and artists who have worked on the program. An about dialog is typically opened when the user selects the About option from the Help menu. All parts of the dialog are optional.

About dialog often contain links and email addresses. @ref{about-dialog} supports this by offering global hooks (TODO: not implemented in cl-gtk2), which are called when the user clicks on a link or email address, see gtk_about_dialog_set_email_hook() and gtk_about_dialog_set_url_hook(). Email addresses in the authors, documenters and artists properties are recognized by looking for @code{<user@@host>}, URLs are recognized by looking for @code{http://url}, with url extending to the next space, tab or line break.

When setting the website and email hooks for the @ref{about-dialog} widget, you should remember that the order is important: you should set the hook functions before setting the website and email URL properties. Otherwise the @ref{about-dialog} widget will not display the website and the email addresses as clickable.

Note that GTK+ sets a default title of @code{_("About %s")} on the dialog window (where @code{%s} is replaced by the name of the application, but in order to ensure proper translation of the title, applications should set the title property explicitly when constructing a @ref{about-dialog}, as shown in the following example:

@lisp
(make-instance 'gtk:about-dialog :program-name "ExampleCode" :title "About ExampleCode")
@end lisp


Slots:
@itemize
@item @anchor{slot.about-dialog.artists}artists. Type: list of @code{string}. Accessor: @anchor{fn.about-dialog-artists}@code{about-dialog-artists}.

The people who contributed artwork to the program, as a list of strings. Each string may contain email addresses and URLs, which will be displayed as links, see the description for more details.
@item @anchor{slot.about-dialog.authors}authors. Type: list of @code{string}. Accessor: @anchor{fn.about-dialog-authors}@code{about-dialog-authors}.

The authors of the program, as a list of strings. Each string may contain email addresses and URLs, which will be displayed as links, see the introduction for more details.
@item @anchor{slot.about-dialog.comments}comments. Type: @code{string}. Accessor: @anchor{fn.about-dialog-comments}@code{about-dialog-comments}.

Comments about the program. This string is displayed in a label in the main dialog, thus it should be a short explanation of the main purpose of the program, not a detailed list of features.

Default value: NIL
@item @anchor{slot.about-dialog.copyright}copyright. Type: @code{string}. Accessor: @anchor{fn.about-dialog-copyright}@code{about-dialog-copyright}.

Copyright information for the program.

Default value: NIL
@item @anchor{slot.about-dialog.documenters}documenters. Type: list of @code{string}. Accessor: @anchor{fn.about-dialog-documenters}@code{about-dialog-documenters}.

The people documenting the program, as a list of strings. Each string may contain email addresses and URLs, which will be displayed as links, see the introduction for more details.
@item @anchor{slot.about-dialog.license}license. Type: @code{string}. Accessor: @anchor{fn.about-dialog-license}@code{about-dialog-license}.

The license of the program. This string is displayed in a text view in a secondary dialog, therefore it is fine to use a long multi-paragraph text. Note that the text is only wrapped in the text view if the @SlotRef{about-dialog,wrap-license} property is set to True; otherwise the text itself must contain the intended linebreaks.

Default value: NIL
@item @anchor{slot.about-dialog.logo}logo. Type: @ref{pixbuf}. Accessor: @anchor{fn.about-dialog-logo}@code{about-dialog-logo}.

A logo for the about box. If this is not set, it defaults to gtk_window_get_default_icon_list().
@item @anchor{slot.about-dialog.logo-icon-name}logo-icon-name. Type: @code{string}. Accessor: @anchor{fn.about-dialog-logo-icon-name}@code{about-dialog-logo-icon-name}.

A named icon to use as the logo for the about box. This property overrides the @SlotRef{about-dialog,logo} property.

Default value: NIL
@item @anchor{slot.about-dialog.program-name}program-name. Type: @code{string}. Accessor: @anchor{fn.about-dialog-program-name}@code{about-dialog-program-name}.

The name of the program. If this is not set, it defaults to g_get_application_name().

Default value: NIL
@item @anchor{slot.about-dialog.translator-credits}translator-credits. Type: @code{string}. Accessor: @anchor{fn.about-dialog-translator-credits}@code{about-dialog-translator-credits}.

Credits to the translators. This string should be marked as translatable. The string may contain email addresses and URLs, which will be displayed as links, see the introduction for more details.

Default value: NIL
@item @anchor{slot.about-dialog.version}version. Type: @code{string}. Accessor: @anchor{fn.about-dialog-version}@code{about-dialog-version}.

The version of the program.

Default value: NIL
@item @anchor{slot.about-dialog.website}website. Type: @code{string}. Accessor: @anchor{fn.about-dialog-website}@code{about-dialog-website}.

The URL for the link to the website of the program. This should be a string starting with "http://.

Default value: NIL
@item @anchor{slot.about-dialog.website-label}website-label. Type: @code{string}. Accessor: @anchor{fn.about-dialog-website-label}@code{about-dialog-website-label}.

The label for the link to the website of the program. If this is not set, it defaults to the URL specified in the website property.

Default value: NIL
@item @anchor{slot.about-dialog.wrap-license}wrap-license. Type: @code{boolean}. Accessor: @anchor{fn.about-dialog-wrap-license}@code{about-dialog-wrap-license}.

Whether to wrap the text in the license dialog.

Default value: False
@end itemize

Signals:
@itemize
@end itemize




@node accel-label
@section accel-label
@Class accel-label
Superclass: @ref{label} @ref{atk-implementor-iface} @ref{buildable}

The @ref{accel-label} widget is a subclass of @ref{label} that also displays an accelerator key on the right of the label text, e.g. 'Ctl+S'. It is commonly used in menus to show the keyboard short-cuts for commands.

The accelerator key to display is not set explicitly. Instead, the @ref{accel-label} displays the accelerators which have been added to a particular widget. This widget is set by @SlotRef{accel-label,accel-widget}.

For example, a @ref{menu-item} widget may have an accelerator added to emit the @SignalRef{menu-item,activate} signal when the 'Ctl+S' key combination is pressed. A @ref{accel-label} is created and added to the @ref{accel-label}, and @SlotRef{accel-label,accel-widget} is set to the @ref{menu-item} as the second argument. The @ref{accel-label} will now display 'Ctl+S' after its label.

@c Note that creating a @ref{menu-item} with gtk_menu_item_new_with_label() (or one of the similar functions for GtkCheckMenuItem and GtkRadioMenuItem) automatically adds a GtkAccelLabel to the GtkMenuItem and calls gtk_accel_label_set_accel_widget() to set it up for you.

A @ref{accel-label} will only display accelerators which have @FlagsVRef{accel-flags,visible} set. A@ref{accel-label} can display multiple accelerators and even signal names, though it is almost always used to display just one accelerator key.

Slots:
@itemize
@item @anchor{slot.accel-label.accel-closure}accel-closure. Type: @code{GClosure}. Accessor: @anchor{fn.accel-label-accel-closure}@code{accel-label-accel-closure}.

The closure to be monitored for accelerator changes.

TODO: GClosure type mapping is not supported
@item @anchor{slot.accel-label.accel-widget}accel-widget. Type: @ref{widget}. Accessor: @anchor{fn.accel-label-accel-widget}@code{accel-label-accel-widget}.

The widget to be monitored for accelerator changes.
@end itemize


Signals:
@itemize
@end itemize




@node alignment
@section alignment
@Class alignment
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.alignment.bottom-padding}bottom-padding. Type: @code{integer}. Accessor: @anchor{fn.alignment-bottom-padding}@code{alignment-bottom-padding}.
@item @anchor{slot.alignment.left-padding}left-padding. Type: @code{integer}. Accessor: @anchor{fn.alignment-left-padding}@code{alignment-left-padding}.
@item @anchor{slot.alignment.right-padding}right-padding. Type: @code{integer}. Accessor: @anchor{fn.alignment-right-padding}@code{alignment-right-padding}.
@item @anchor{slot.alignment.top-padding}top-padding. Type: @code{integer}. Accessor: @anchor{fn.alignment-top-padding}@code{alignment-top-padding}.
@item @anchor{slot.alignment.xalign}xalign. Type: @code{single-float}. Accessor: @anchor{fn.alignment-xalign}@code{alignment-xalign}.
@item @anchor{slot.alignment.xscale}xscale. Type: @code{single-float}. Accessor: @anchor{fn.alignment-xscale}@code{alignment-xscale}.
@item @anchor{slot.alignment.yalign}yalign. Type: @code{single-float}. Accessor: @anchor{fn.alignment-yalign}@code{alignment-yalign}.
@item @anchor{slot.alignment.yscale}yscale. Type: @code{single-float}. Accessor: @anchor{fn.alignment-yscale}@code{alignment-yscale}.
@end itemize


Signals:
@itemize
@end itemize




@node arrow
@section arrow
@Class arrow
Superclass: @ref{misc} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.arrow.arrow-type}arrow-type. Type: @ref{arrow-type}. Accessor: @anchor{fn.arrow-arrow-type}@code{arrow-arrow-type}.
@item @anchor{slot.arrow.shadow-type}shadow-type. Type: @ref{shadow-type}. Accessor: @anchor{fn.arrow-shadow-type}@code{arrow-shadow-type}.
@end itemize


Signals:
@itemize
@end itemize




@node aspect-frame
@section aspect-frame
@Class aspect-frame
Superclass: @ref{frame} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.aspect-frame.obey-child}obey-child. Type: @code{boolean}. Accessor: @anchor{fn.aspect-frame-obey-child}@code{aspect-frame-obey-child}.
@item @anchor{slot.aspect-frame.ratio}ratio. Type: @code{single-float}. Accessor: @anchor{fn.aspect-frame-ratio}@code{aspect-frame-ratio}.
@item @anchor{slot.aspect-frame.xalign}xalign. Type: @code{single-float}. Accessor: @anchor{fn.aspect-frame-xalign}@code{aspect-frame-xalign}.
@item @anchor{slot.aspect-frame.yalign}yalign. Type: @code{single-float}. Accessor: @anchor{fn.aspect-frame-yalign}@code{aspect-frame-yalign}.
@end itemize


Signals:
@itemize
@end itemize




@node assistant
@section assistant
@Class assistant
Superclass: @ref{gtk-window} @ref{atk-implementor-iface} @ref{buildable}

A @ref{assistant} is a widget used to represent a generally complex operation splitted in several steps, guiding the user through its pages and controlling the page flow to collect the necessary data.

Slots:
@itemize
@item @anchor{slot.assistant.current-page}current-page. Type: @code{integer}. Accessor: @anchor{fn.assistant-current-page}@code{assistant-current-page}.

The index (starting from 0) of the current page in the assistant, or -1 if the assistant has no pages.
@item @anchor{slot.assistant.forward-page-function}forward-page-function. function. Accessor: @anchor{fn.assistant-forward-page-function}@code{assistant-forward-page-function}. Write-only.

Page forwarding function is used to determine what will be the next page when the user presses the forward button. Setting this to NIL will make the assistant to use the default forward function, which just goes to the next visible page.
The function called both for computing the next page when the user presses the "forward" button and for handling the behavior of the "last" button. The function accepts a single integer - the current page number and returns the page number for the next page.
@item @anchor{slot.assistant.n-pages}n-pages. Type: @code{integer}. Accessor: @anchor{fn.assistant-n-pages}@code{assistant-n-pages}. Read-only.

The number of pages in the assistant
@end itemize


Signals:
@itemize
@item @anchor{signal.assistant.apply}"apply". Signature: (instance @ref{assistant}) @result{} void. Options: run-last.

This signal is emitted when the apply button is clicked. The default behavior of the @ref{assistant} is to switch to the page after the current page, unless the current page is the last one.

A handler for the @SignalRef{assistant,apply} signal should carry out the actions for which the wizard has collected data. If the action takes a long time to complete, you might consider to put a page of type @EnumVRef{assistant-page-type,progress} after the confirmation page and handle this operation within the @SignalRef{assistant,prepare} signal of the progress page.
@item @anchor{signal.assistant.cancel}"cancel". Signature: (instance @ref{assistant}) @result{} void. Options: run-last.

This signal is emitted when then the cancel button is clicked.
@item @anchor{signal.assistant.close}"close". Signature: (instance @ref{assistant}) @result{} void. Options: run-last.

This signal is emitted either when the close button of a summary page is clicked, or when the apply button in the last page in the flow (of type @EnumVRef{assistant-page-type,confirm}) is clicked.
@item @anchor{signal.assistant.prepare}"prepare". Signature: (instance @ref{assistant}), (page @ref{widget}) @result{} void. Options: run-last.

This signal is emitted when a new page is set as the assistant's current page, before making the new page visible. A handler for this signal can do any preparation which are necessary before showing page.
@end itemize

@RMethod assistant-nth-page
@lisp
(assistant-nth-page assistant page-number) @result{} page-widget
@end lisp

Returns the child widget (a @ref{widget}) contained in page number @var{page-number} (an integer).

@RMethod assistant-append-page
@lisp
(assistant-append-page assistant page)
@end lisp

Appends a @var{page} (a @ref{widget}) to the @var{assistant} (a @ref{assistant}).

@RMethod assistant-prepend-page
@lisp
(assistant-prepend-page assistant page)
@end lisp

Prepends a @var{page} (a @ref{widget}) to the @var{assistant} (a @ref{assistant}).

@RMethod assistant-insert-page
@lisp
(assistant-insert-page assistant page position) @result{} page-number
@end lisp

Inserts a @var{page} (a @ref{widget}) in the @var{assistant} (a @ref{assistant}) at a given @var{position}. @var{position} is the index (starting at 0) at which to insert the page, or -1 to append the page. Returns the index of inserted @var{page}.

@RMethod assistant-add-action-widget
@lisp
(assistant-add-action-widget assistant widget)
@end lisp

Adds the @var{widget} (a @ref{widget}) to the action area of a @var{assistant} (a @ref{assistant}).

@RMethod assistant-remove-action-widget
@lisp
(assistant-remove-action-widget assistant widget)
@end lisp

Removes the @var{widget} (a @ref{widget}) from the action area of a @var{assistant} (a @ref{assistant}).

@RMethod assistant-update-buttons-state
@lisp
(assistant-update-buttons-state assistant)
@end lisp

Forces @var{assistant} (a @ref{assistant}) to recompute the buttons state.

GTK+ automatically takes care of this in most situations, e.g. when the user goes to a different page, or when the visibility or completeness of a page changes.

One situation where it can be necessary to call this function is when changing a value on the current page affects the future page flow of the assistant.

@node bin
@section bin
@Class bin
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{viewport} @ref{scrolled-window} @ref{tool-item} @ref{handle-box} @ref{expander} @ref{event-box} @ref{combo-box} @ref{frame} @ref{alignment} @ref{button} @ref{item} @ref{gtk-window}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node box
@section box
@Class box
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{h-box} @ref{v-box} @ref{button-box}

Slots:
@itemize
@item @anchor{slot.box.homogeneous}homogeneous. Type: @code{boolean}. Accessor: @anchor{fn.box-homogeneous}@code{box-homogeneous}.
@item @anchor{slot.box.spacing}spacing. Type: @code{integer}. Accessor: @anchor{fn.box-spacing}@code{box-spacing}.
@end itemize


Signals:
@itemize
@end itemize

@RMethod box-pack-start
@lisp
box-pack-start
@end lisp



@node button
@section button
@Class button
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Subclasses: @ref{scale-button} @ref{link-button} @ref{font-button} @ref{color-button} @ref{toggle-button}

The @ref{button} widget is generally used to attach a function to that is called when the button is pressed. The various signals and how to use them are outlined below.

The @ref{button} widget can hold any valid child widget. That is it can hold most any other standard @ref{widget}. The most commonly used child is the @ref{label}.

Slots:
@itemize
@item @anchor{slot.button.focus-on-click}focus-on-click. Type: @code{boolean}. Accessor: @anchor{fn.button-focus-on-click}@code{button-focus-on-click}.

Whether the button grabs focus when it is clicked with the mouse.

Default value: True
@item @anchor{slot.button.image}image. Type: @ref{widget}. Accessor: @anchor{fn.button-image}@code{button-image}.

Child widget to appear next to the button text.
@item @anchor{slot.button.image-position}image-position. Type: @ref{position-type}. Accessor: @anchor{fn.button-image-position}@code{button-image-position}.

The position of the image relative to the text inside the button.

Default value: @EnumVRef{position-type,left}
@item @anchor{slot.button.label}label. Type: @code{string}. Accessor: @anchor{fn.button-label}@code{button-label}.

Text of the label widget inside the button, if the button contains a label widget.

Default value: NIL
@item @anchor{slot.button.relief}relief. Type: @ref{relief-style}. Accessor: @anchor{fn.button-relief}@code{button-relief}.

The border relief style.

Default value: @EnumVRef{relief-style,normal}
@item @anchor{slot.button.use-stock}use-stock. Type: @code{boolean}. Accessor: @anchor{fn.button-use-stock}@code{button-use-stock}.

If set, the label is used to pick a stock item instead of being displayed.

Default value: False
@item @anchor{slot.button.use-underline}use-underline. Type: @code{boolean}. Accessor: @anchor{fn.button-use-underline}@code{button-use-underline}.

If set, an underline in the text indicates the next character should be used for the mnemonic accelerator key.

Default value: False
@item @anchor{slot.button.xalign}xalign. Type: @code{single-float}. Accessor: @anchor{fn.button-xalign}@code{button-xalign}.

If the child of the button is a @ref{misc} or @ref{alignment}, this property can be used to control it's horizontal alignment. 0.0 is left aligned, 1.0 is right aligned.

Allowed values: [0,1]

Default value: 0.5
@item @anchor{slot.button.yalign}yalign. Type: @code{single-float}. Accessor: @anchor{fn.button-yalign}@code{button-yalign}.

If the child of the button is a @ref{misc} or @ref{alignment}, this property can be used to control it's vertical alignment. 0.0 is left aligned, 1.0 is right aligned.

Allowed values: [0,1]

Default value: 0.5
@end itemize


Signals:
@itemize
@item @anchor{signal.button.activate}"activate". Signature: (instance @ref{button}) @result{} void. Options: run-first, action.

This signal is an action signal and emitting it causes the button to animate press then release. Applications should never connect to this signal, but use the @SignalRef{button,clicked} signal.
@item @anchor{signal.button.clicked}"clicked". Signature: (instance @ref{button}) @result{} void. Options: run-first, action.

Emitted when the button has been activated (pressed and released).
@item @anchor{signal.button.enter}"enter". Signature: (instance @ref{button}) @result{} void. Options: run-first.

Emitted when the pointer enters the button.
@item @anchor{signal.button.leave}"leave". Signature: (instance @ref{button}) @result{} void. Options: run-first.

Emitted when the pointer leaves the button.
@item @anchor{signal.button.pressed}"pressed". Signature: (instance @ref{button}) @result{} void. Options: run-first.

Emitted when the button is pressed.
@item @anchor{signal.button.released}"released". Signature: (instance @ref{button}) @result{} void. Options: run-first.

Emitted when the button is released.
@end itemize




@node button-box
@section button-box
@Class button-box
Superclass: @ref{box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{v-button-box} @ref{h-button-box}

Slots:
@itemize
@item @anchor{slot.button-box.layout-style}layout-style. Type: @ref{button-box-style}. Accessor: @anchor{fn.button-box-layout-style}@code{button-box-layout-style}.
@end itemize


Signals:
@itemize
@end itemize




@node calendar
@section calendar
@Class calendar
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.calendar.day}day. Type: @code{integer}. Accessor: @anchor{fn.calendar-day}@code{calendar-day}.
@item @anchor{slot.calendar.detail-function}detail-function. Type: ????. Accessor: @anchor{fn.calendar-detail-function}@code{calendar-detail-function}. Write-only.
@item @anchor{slot.calendar.detail-height-rows}detail-height-rows. Type: @code{integer}. Accessor: @anchor{fn.calendar-detail-height-rows}@code{calendar-detail-height-rows}.
@item @anchor{slot.calendar.detail-width-chars}detail-width-chars. Type: @code{integer}. Accessor: @anchor{fn.calendar-detail-width-chars}@code{calendar-detail-width-chars}.
@item @anchor{slot.calendar.month}month. Type: @code{integer}. Accessor: @anchor{fn.calendar-month}@code{calendar-month}.
@item @anchor{slot.calendar.no-month-change}no-month-change. Type: @code{boolean}. Accessor: @anchor{fn.calendar-no-month-change}@code{calendar-no-month-change}.
@item @anchor{slot.calendar.show-day-names}show-day-names. Type: @code{boolean}. Accessor: @anchor{fn.calendar-show-day-names}@code{calendar-show-day-names}.
@item @anchor{slot.calendar.show-details}show-details. Type: @code{boolean}. Accessor: @anchor{fn.calendar-show-details}@code{calendar-show-details}.
@item @anchor{slot.calendar.show-heading}show-heading. Type: @code{boolean}. Accessor: @anchor{fn.calendar-show-heading}@code{calendar-show-heading}.
@item @anchor{slot.calendar.show-week-numbers}show-week-numbers. Type: @code{boolean}. Accessor: @anchor{fn.calendar-show-week-numbers}@code{calendar-show-week-numbers}.
@item @anchor{slot.calendar.year}year. Type: @code{integer}. Accessor: @anchor{fn.calendar-year}@code{calendar-year}.
@end itemize


Signals:
@itemize
@item @anchor{signal.calendar.day-selected}"day-selected". Signature: (instance @ref{calendar}) @result{} void. Options: run-first.
@item @anchor{signal.calendar.day-selected-double-click}"day-selected-double-click". Signature: (instance @ref{calendar}) @result{} void. Options: run-first.
@item @anchor{signal.calendar.month-changed}"month-changed". Signature: (instance @ref{calendar}) @result{} void. Options: run-first.
@item @anchor{signal.calendar.next-month}"next-month". Signature: (instance @ref{calendar}) @result{} void. Options: run-first.
@item @anchor{signal.calendar.next-year}"next-year". Signature: (instance @ref{calendar}) @result{} void. Options: run-first.
@item @anchor{signal.calendar.prev-month}"prev-month". Signature: (instance @ref{calendar}) @result{} void. Options: run-first.
@item @anchor{signal.calendar.prev-year}"prev-year". Signature: (instance @ref{calendar}) @result{} void. Options: run-first.
@end itemize




@node cell-view
@section cell-view
@Class cell-view
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable} @ref{cell-layout}

Slots:
@itemize
@item @anchor{slot.cell-view.background}background. Type: @code{string}. Accessor: @anchor{fn.cell-view-background}@code{cell-view-background}. Write-only.
@item @anchor{slot.cell-view.background-gdk}background-gdk. Type: @ref{color}. Accessor: @anchor{fn.cell-view-background-gdk}@code{cell-view-background-gdk}.
@item @anchor{slot.cell-view.background-set}background-set. Type: @code{boolean}. Accessor: @anchor{fn.cell-view-background-set}@code{cell-view-background-set}.
@item @anchor{slot.cell-view.displayed-row}displayed-row. Type: @ref{tree-path}. Accessor: @anchor{fn.cell-view-displayed-row}@code{cell-view-displayed-row}.
@item @anchor{slot.cell-view.model}model. Type: @ref{tree-model}. Accessor: @anchor{fn.cell-view-model}@code{cell-view-model}.
@end itemize


Signals:
@itemize
@end itemize




@node check-button
@section check-button
@Class check-button
Superclass: @ref{toggle-button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Subclasses: @ref{radio-button}


A @ref{check-button} places a discrete @ref{toggle-button} next to a widget, (usually a @ref{label}). See the @ref{toggle-button} for more information about toggle/check buttons.

The important signal @SignalRef{toggle-button,toggled} is also inherited from @ref{toggle-button}.

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node check-menu-item
@section check-menu-item
@Class check-menu-item
Superclass: @ref{menu-item} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Subclasses: @ref{radio-menu-item}

Slots:
@itemize
@item @anchor{slot.check-menu-item.active}active. Type: @code{boolean}. Accessor: @anchor{fn.check-menu-item-active}@code{check-menu-item-active}.
@item @anchor{slot.check-menu-item.draw-as-radio}draw-as-radio. Type: @code{boolean}. Accessor: @anchor{fn.check-menu-item-draw-as-radio}@code{check-menu-item-draw-as-radio}.
@item @anchor{slot.check-menu-item.inconsistent}inconsistent. Type: @code{boolean}. Accessor: @anchor{fn.check-menu-item-inconsistent}@code{check-menu-item-inconsistent}.
@end itemize


Signals:
@itemize
@item @anchor{signal.check-menu-item.toggled}"toggled". Signature: (instance @ref{check-menu-item}) @result{} void. Options: run-first.
@end itemize




@node color-button
@section color-button
@Class color-button
Superclass: @ref{button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.color-button.alpha}alpha. Type: @code{integer}. Accessor: @anchor{fn.color-button-alpha}@code{color-button-alpha}.
@item @anchor{slot.color-button.color}color. Type: @ref{color}. Accessor: @anchor{fn.color-button-color}@code{color-button-color}.
@item @anchor{slot.color-button.title}title. Type: @code{string}. Accessor: @anchor{fn.color-button-title}@code{color-button-title}.
@item @anchor{slot.color-button.use-alpha}use-alpha. Type: @code{boolean}. Accessor: @anchor{fn.color-button-use-alpha}@code{color-button-use-alpha}.
@end itemize


Signals:
@itemize
@item @anchor{signal.color-button.color-set}"color-set". Signature: (instance @ref{color-button}) @result{} void. Options: run-first.
@end itemize




@node color-selection
@section color-selection
@Class color-selection
Superclass: @ref{v-box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@item @anchor{slot.color-selection.current-alpha}current-alpha. Type: @code{integer}. Accessor: @anchor{fn.color-selection-current-alpha}@code{color-selection-current-alpha}.
@item @anchor{slot.color-selection.current-color}current-color. Type: @ref{color}. Accessor: @anchor{fn.color-selection-current-color}@code{color-selection-current-color}.
@item @anchor{slot.color-selection.has-opacity-control}has-opacity-control. Type: @code{boolean}. Accessor: @anchor{fn.color-selection-has-opacity-control}@code{color-selection-has-opacity-control}.
@item @anchor{slot.color-selection.has-palette}has-palette. Type: @code{boolean}. Accessor: @anchor{fn.color-selection-has-palette}@code{color-selection-has-palette}.
@end itemize


Signals:
@itemize
@item @anchor{signal.color-selection.color-changed}"color-changed". Signature: (instance @ref{color-selection}) @result{} void. Options: run-first.
@end itemize




@node color-selection-dialog
@section color-selection-dialog
@Class color-selection-dialog
Superclass: @ref{dialog} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.color-selection-dialog.cancel-button}cancel-button. Type: @ref{widget}. Accessor: @anchor{fn.color-selection-dialog-cancel-button}@code{color-selection-dialog-cancel-button}. Read-only.
@item @anchor{slot.color-selection-dialog.color-selection}color-selection. Type: @ref{widget}. Accessor: @anchor{fn.color-selection-dialog-color-selection}@code{color-selection-dialog-color-selection}. Read-only.
@item @anchor{slot.color-selection-dialog.help-button}help-button. Type: @ref{widget}. Accessor: @anchor{fn.color-selection-dialog-help-button}@code{color-selection-dialog-help-button}. Read-only.
@item @anchor{slot.color-selection-dialog.ok-button}ok-button. Type: @ref{widget}. Accessor: @anchor{fn.color-selection-dialog-ok-button}@code{color-selection-dialog-ok-button}. Read-only.
@end itemize


Signals:
@itemize
@end itemize




@node combo-box
@section combo-box
@Class combo-box
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable} @ref{cell-editable} @ref{cell-layout}

Subclasses: @ref{combo-box-entry}

Slots:
@itemize
@item @anchor{slot.combo-box.active}active. Type: @code{integer}. Accessor: @anchor{fn.combo-box-active}@code{combo-box-active}.
@item @anchor{slot.combo-box.active-iter}active-iter. Type: @ref{tree-iter}. Accessor: @anchor{fn.combo-box-active-iter}@code{combo-box-active-iter}.
@item @anchor{slot.combo-box.add-tearoffs}add-tearoffs. Type: @code{boolean}. Accessor: @anchor{fn.combo-box-add-tearoffs}@code{combo-box-add-tearoffs}.
@item @anchor{slot.combo-box.button-sensitivity}button-sensitivity. Type: @ref{sensitivity-type}. Accessor: @anchor{fn.combo-box-button-sensitivity}@code{combo-box-button-sensitivity}.
@item @anchor{slot.combo-box.column-span-column}column-span-column. Type: @code{integer}. Accessor: @anchor{fn.combo-box-column-span-column}@code{combo-box-column-span-column}.
@item @anchor{slot.combo-box.focus-on-click}focus-on-click. Type: @code{boolean}. Accessor: @anchor{fn.combo-box-focus-on-click}@code{combo-box-focus-on-click}.
@item @anchor{slot.combo-box.has-frame}has-frame. Type: @code{boolean}. Accessor: @anchor{fn.combo-box-has-frame}@code{combo-box-has-frame}.
@item @anchor{slot.combo-box.model}model. Type: @ref{tree-model}. Accessor: @anchor{fn.combo-box-model}@code{combo-box-model}.
@item @anchor{slot.combo-box.popup-shown}popup-shown. Type: @code{boolean}. Accessor: @anchor{fn.combo-box-popup-shown}@code{combo-box-popup-shown}. Read-only.
@item @anchor{slot.combo-box.row-separator-func}row-separator-func. Type: ????. Accessor: @anchor{fn.combo-box-row-separator-func}@code{combo-box-row-separator-func}. Write-only.
@item @anchor{slot.combo-box.row-span-column}row-span-column. Type: @code{integer}. Accessor: @anchor{fn.combo-box-row-span-column}@code{combo-box-row-span-column}.
@item @anchor{slot.combo-box.tearoff-title}tearoff-title. Type: @code{string}. Accessor: @anchor{fn.combo-box-tearoff-title}@code{combo-box-tearoff-title}.
@item @anchor{slot.combo-box.wrap-width}wrap-width. Type: @code{integer}. Accessor: @anchor{fn.combo-box-wrap-width}@code{combo-box-wrap-width}.
@end itemize


Signals:
@itemize
@item @anchor{signal.combo-box.changed}"changed". Signature: (instance @ref{combo-box}) @result{} void. Options: run-last.
@item @anchor{signal.combo-box.move-active}"move-active". Signature: (instance @ref{combo-box}), (arg-1 @ref{scroll-type}) @result{} void. Options: run-last, action.
@item @anchor{signal.combo-box.popdown}"popdown". Signature: (instance @ref{combo-box}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.combo-box.popup}"popup". Signature: (instance @ref{combo-box}) @result{} void. Options: run-last, action.
@end itemize




@node combo-box-entry
@section combo-box-entry
@Class combo-box-entry
Superclass: @ref{combo-box} @ref{atk-implementor-iface} @ref{buildable} @ref{cell-editable} @ref{cell-layout}

Slots:
@itemize
@item @anchor{slot.combo-box-entry.text-column}text-column. Type: @code{integer}. Accessor: @anchor{fn.combo-box-entry-text-column}@code{combo-box-entry-text-column}.
@end itemize


Signals:
@itemize
@end itemize




@node container
@section container
@Class container
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{toolbar} @ref{text-view} @ref{table} @ref{socket} @ref{layout} @ref{paned} @ref{fixed} @ref{box} @ref{icon-view} @ref{tree-view} @ref{notebook} @ref{menu-shell} @ref{bin}

Slots:
@itemize
@item @anchor{slot.container.border-width}border-width. Type: @code{integer}. Accessor: @anchor{fn.container-border-width}@code{container-border-width}.
@item @anchor{slot.container.child}child. Type: @ref{widget}. Accessor: @anchor{fn.container-child}@code{container-child}. Write-only.
@item @anchor{slot.container.focus-child}focus-child. Type: @ref{g-object}. Accessor: @anchor{fn.container-focus-child}@code{container-focus-child}.
@item @anchor{slot.container.focus-hadjustment}focus-hadjustment. Type: @ref{g-object}. Accessor: @anchor{fn.container-focus-hadjustment}@code{container-focus-hadjustment}.
@item @anchor{slot.container.focus-vadjustment}focus-vadjustment. Type: @ref{g-object}. Accessor: @anchor{fn.container-focus-vadjustment}@code{container-focus-vadjustment}.
@item @anchor{slot.container.resize-mode}resize-mode. Type: @ref{resize-mode}. Accessor: @anchor{fn.container-resize-mode}@code{container-resize-mode}.
@end itemize


Signals:
@itemize
@item @anchor{signal.container.add}"add". Signature: (instance @ref{container}), (arg-1 @ref{widget}) @result{} void. Options: run-first.
@item @anchor{signal.container.check-resize}"check-resize". Signature: (instance @ref{container}) @result{} void. Options: run-last.
@item @anchor{signal.container.remove}"remove". Signature: (instance @ref{container}), (arg-1 @ref{widget}) @result{} void. Options: run-first.
@item @anchor{signal.container.set-focus-child}"set-focus-child". Signature: (instance @ref{container}), (arg-1 @ref{widget}) @result{} void. Options: run-first.
@end itemize




@node curve
@section curve
@Class curve
Superclass: @ref{drawing-area} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.curve.curve-type}curve-type. Type: @ref{curve-type}. Accessor: @anchor{fn.curve-curve-type}@code{curve-curve-type}.
@item @anchor{slot.curve.max-x}max-x. Type: @code{single-float}. Accessor: @anchor{fn.curve-max-x}@code{curve-max-x}.
@item @anchor{slot.curve.max-y}max-y. Type: @code{single-float}. Accessor: @anchor{fn.curve-max-y}@code{curve-max-y}.
@item @anchor{slot.curve.min-x}min-x. Type: @code{single-float}. Accessor: @anchor{fn.curve-min-x}@code{curve-min-x}.
@item @anchor{slot.curve.min-y}min-y. Type: @code{single-float}. Accessor: @anchor{fn.curve-min-y}@code{curve-min-y}.
@end itemize


Signals:
@itemize
@item @anchor{signal.curve.curve-type-changed}"curve-type-changed". Signature: (instance @ref{curve}) @result{} void. Options: run-first.
@end itemize




@node dialog
@section dialog
@Class dialog
Superclass: @ref{gtk-window} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{recent-chooser-dialog} @ref{message-dialog} @ref{input-dialog} @ref{font-selection-dialog} @ref{file-chooser-dialog} @ref{color-selection-dialog} @ref{about-dialog}

Dialog boxes are a convenient way to prompt the user for a small amount of input, e.g. to display a message, ask a question, or anything else that does not require extensive effort on the user's part.

GTK+ treats a dialog as a window split vertically. The top section is a @ref{v-box}, and is where widgets such as a @ref{label} or a @ref{entry} should be packed. The bottom area is known as the @SlotRef{dialog,action-area}. This is generally used for packing buttons into the dialog which may perform functions such as cancel, ok, or apply. The two areas are separated by a @ref{h-separator}.

If 'dialog' is a newly created dialog, the two primary areas of the window can be accessed through @SlotRef{dialog,content-area} and @SlotRef{dialog,action-area}.

A 'modal' dialog (that is, one which freezes the rest of the application from user input), can be created by setting @SlotRef{gtk-window,modal} (e.g., by specifying @code{:modal t} initarg).

If you add buttons to @ref{dialog} using @ref{dialog-add-button}, or @ref{dialog-add-action-widget}, clicking the button will emit a @SignalRef{dialog,response} signal with a response ID that was specified. GTK+ will never assign a meaning to positive response IDs; these are entirely user-defined. But for convenience, you can use the response IDs in the @ref{response-type} enumeration (these all have values less than zero). If a dialog receives a delete event, the @SignalRef{dialog,response} signal will be emitted with a response ID of @EnumVRef{response-type,delete-event}.

TODO: cl-gtk2 does not yet support specifying custom response IDs.

If you want to block waiting for a dialog to return before returning control flow to your code, you can call @ref{dialog-run}. This function enters a recursive main loop and waits for the user to respond to the dialog, returning the response ID corresponding to the button the user clicked.

For the simple dialog in the following example, in reality you'd probably use @ref{message-dialog} to save yourself some effort. But you'd need to create the dialog contents manually if you had more than a simple message in the dialog.

@lisp
(defun quick-message (message)
  "Function to open a dialog box display the MESSAGE"
  (let ((dialog (make-instance 'gtk:dialog :title "Message")))
    (gtk:dialog-add-button dialog "gtk-ok" :none)
    (gtk:container-add (gtk:dialog-content-area dialog)
                       (make-instance 'gtk:label :label message))
    (gobject:connect-signal dialog "response"
                            (lambda (dialog1 response-id)
                              (declare (ignore dialog1 response-id))
                              (gtk:object-destroy dialog)))
    (gtk:widget-show dialog)))
@end lisp

Slots:
@itemize
@item @anchor{slot.dialog.action-area}action-area. Type: @ref{v-box}. Accessor: @anchor{fn.dialog-action-area}@code{dialog-action-area}. Read-only.

The action area of dialog.
@item @anchor{slot.dialog.alternative-button-order}alternative-button-order. Type: @code{list of @ref{response-type}}. Accessor: @anchor{fn.dialog-alternative-button-order}@code{dialog-alternative-button-order}. Write-only.

Sets an alternative button order. If the "gtk-alternative-button-order" setting is set to True, the dialog buttons are reordered according to the order of the response ids passed to this function.

By default, GTK+ dialogs use the button order advocated by the Gnome Human Interface Guidelines with the affirmative button at the far right, and the cancel button left of it. But the builtin GTK+ dialogs and @ref{message-dialog}s do provide an alternative button order, which is more suitable on some platforms, e.g. Windows.

Set this after adding all the buttons to your dialog, as the following example shows:

@lisp
(setf (dialog-alternative-button-order dialog) '(:ok :cancel :help))
@end lisp

@item @anchor{slot.dialog.content-area}content-area. Type: @ref{widget}. Accessor: @anchor{fn.dialog-content-area}@code{dialog-content-area}. Read-only.

The content area of dialog.

@item @anchor{slot.dialog.default-response}default-response. Type: @ref{response-type}. Accessor: @anchor{fn.dialog-default-response}@code{dialog-default-response}. Write-only.

The widget in the dialog's action area with the given this response is the default widget for the dialog. Pressing "Enter" normally activates the default widget.
@item @anchor{slot.dialog.has-separator}has-separator. Type: @code{boolean}. Accessor: @anchor{fn.dialog-has-separator}@code{dialog-has-separator}.


When True, the dialog has a separator bar above its buttons.

Default value: True
@end itemize


Signals:
@itemize
@item @anchor{signal.dialog.close}"close". Signature: (instance @ref{dialog}) @result{} void. Options: run-last, action.

The close signal is a keybinding signal which gets emitted when the user uses a keybinding to close the dialog.

The default binding for this signal is the Escape key.
@item @anchor{signal.dialog.response}"response". Signature: (instance @ref{dialog}), (response-id @code{integer}) @result{} void. Options: run-last.

Emitted when an action widget is clicked, the dialog receives a delete event, or the application programmer calls @ref{dialog-response}. On a delete event, the response ID is @EnumVRef{response-type,delete-event}. Otherwise, it depends on which action widget was clicked.

Note: because of some limitations, @var{response-id} is an integer. Use @code{(cffi:foreign-enum-keyword 'gtk:response-type response-id)} to get the value of type @ref{response-type}.
@end itemize

@RMethod dialog-run
@lisp
(dialog-run dialog) @result{} response
@end lisp

Blocks in a recursive main loop until the dialog either emits the @SignalRef{dialog,response} signal, or is destroyed. If the dialog is destroyed during the call to @ref{dialog-run}, it returns @EnumVRef{response-type,none}. Otherwise, it returns the response ID from the @SignalRef{dialog,response} signal emission.

Before entering the recursive main loop, @ref{dialog-run} calls @code{widget-show} on the dialog for you. Note that you still need to show any children of the dialog yourself.

During @ref{dialog-run}, the default behavior of @SignalRef{widget,delete-event} is disabled; if the dialog receives @SignalRef{widget,delete-event}, it will not be destroyed as windows usually are, and @ref{dialog-run} will return @EnumVRef{response-type,delete-event}. Also, during @ref{dialog-run} the dialog will be modal. You can force @ref{dialog-run} to return at any time by calling @ref{dialog-response} to emit the @SignalRef{dialog,response} signal. Destroying the dialog during @ref{dialog-run} is a very bad idea, because your post-run code won't know whether the dialog was destroyed or not.

After @ref{dialog-run} returns, you are responsible for hiding or destroying the dialog if you wish to do so.

Note that even though the recursive main loop gives the effect of a modal dialog (it prevents the user from interacting with other windows in the same window group while the dialog is run), callbacks such as timeouts, IO channel watches, DND drops, etc, will be triggered during a @ref{dialog-run} call.

@RMethod dialog-response
@lisp
(dialog-response dialog response)
@end lisp

Emits the @SignalRef{dialog,response} signal with the given @var{response} (of type @ref{response-type}). Used to indicate that the user has responded to the @var{dialog} in some way; typically either you or @ref{dialog-run} will be monitoring the @SignalRef{dialog,response} signal and take appropriate action.

@RMethod dialog-add-button
@lisp
(dialog-add-button dialog text response) @result{} button
@end lisp

Adds a button with the given @var{text} (or a stock button, if @var{text} is a stock ID) and sets things up so that clicking the button will emit the @SignalRef{dialog,response} signal with the given @var{response}. The button is appended to the end of the dialog's action area. The @ref{button} widget is returned, but usually you don't need it.

@RMethod dialog-add-action-widget
@lisp
(dialog-add-action-widget dialog widget response)
@end lisp

Adds an activatable @var{widget} to the action area of a @var{dialog}, connecting a signal handler that will emit the @SignalRef{dialog,response} signal on the dialog when the @var{widget} is activated. The @var{widget} is appended to the end of the dialog's action area. If you want to add a non-activatable widget, simply pack it into the @SlotRef{dialog,action-area} field of the @ref{dialog}.

@RMethod dialog-set-response-sensitive
@lisp
(dialog-set-response-sensitive dialog response setting)
@end lisp

Sets the @SlotRef{widget,sensitive} for each widget in the dialog's action area with the given @var{response}. A convenient way to sensitize/desensitize dialog buttons.

@RMethod dialog-response-for-widget
@lisp
(dialog-response-for-widget dialog widget) @result{} response
@end lisp

Gets the @var{response} (of type @ref{response-type}) of a @var{widget} in the action area of a @var{dialog}.

@RMethod dialog-alternative-button-order-on-screen
@lisp
(dialog-alternative-button-order-on-screen screen) @result{} boolean
@end lisp

Returns True if dialogs are expected to use an alternative button order on the @ref{screen} @var{screen}. See @SlotRef{dialog,alternative-button-order} for more details about alternative button order.

If you need to use this method, you should probably connect to the ::notify:gtk-alternative-button-order signal on the GtkSettings object associated to screen, in order to be notified if the button order setting changes.

@var{screen}: a @ref{screen} or a NIL if to use a default screen.

@node drawing-area
@section drawing-area
@Class drawing-area
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{curve}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node entry
@section entry
@Class entry
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable} @ref{cell-editable} @ref{editable}

Subclasses: @ref{spin-button}

The @ref{entry} widget is a single line text entry widget. A fairly large set of key bindings are supported by default. If the entered text is longer than the allocation of the widget, the widget will scroll so that the cursor position is visible.

When using an entry for passwords and other sensitive information, it can be put into "password mode" using @SlotRef{entry,visibility}. In this mode, entered text is displayed using a 'invisible' character. By default, GTK+ picks the best invisible character that is available in the current font, but it can be changed with @SlotRef{entry,invisible-char}. Since 2.16, GTK+ displays a warning when Caps Lock or input methods might interfere with entering text in a password entry. The warning can be turned off with the @SlotRef{entry,caps-lock-warning} property.

Since 2.16, @ref{entry} has the ability to display progress or activity information behind the text. To make an entry display such information, use @SlotRef{entry,progress-fraction} or @SlotRef{entry,progress-pulse-step},

Additionally, @ref{entry} can show icons at either side of the entry. These icons can be activatable by clicking, can be set up as drag source and can have tooltips. To add an icon, use @SlotRef{entry,primary-icon-gicon} or one of the various other properties that set an icon from a stock id, an icon name or a pixbuf. To trigger an action when the user clicks an icon, connect to the @SignalRef{entry,icon-press} signal. To allow DND operations from an icon, use gtk_entry_set_icon_drag_source(). To set a tooltip on an icon, use @SlotRef{entry,primary-icon-tooltip-text} or @SlotRef{entry,primary-icon-tooltip-markup}. Secondary icon works the same way.

Note that functionality or information that is only available by clicking on an icon in an entry may not be accessible at all to users which are not able to use a mouse or other pointing device. It is therefore recommended that any such functionality should also be available by other means, e.g. via the context menu of the entry.


Slots:
@itemize
@item @anchor{slot.entry.activates-default}activates-default. Type: @code{boolean}. Accessor: @anchor{fn.entry-activates-default}@code{entry-activates-default}.

Whether to activate the default widget (such as the default button in a dialog) when Enter is pressed.

Default value: False
@item @anchor{slot.entry.caps-lock-warning}caps-lock-warning. Type: @code{boolean}. Accessor: @anchor{fn.entry-caps-lock-warning}@code{entry-caps-lock-warning}.

Whether password entries will show a warning when Caps Lock is on.

Note that the warning is shown using a secondary icon, and thus does not work if you are using the secondary icon position for some other purpose.

Default value: True
@item @anchor{slot.entry.completion}completion. Type: @ref{entry-completion}. Accessor: @anchor{fn.entry-completion}@code{entry-completion}.

The current position of the insertion cursor in chars.

Allowed values: [0,65535]

Default value: 0
@item @anchor{slot.entry.cursor-hadjustment}cursor-hadjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.entry-cursor-hadjustment}@code{entry-cursor-hadjustment}.

The adjustment that is bound to the cursor position.

The adjustment has to be in pixel units and in the same coordinate system as the entry.
@item @anchor{slot.entry.cursor-position}cursor-position. Type: @code{integer}. Accessor: @anchor{fn.entry-cursor-position}@code{entry-cursor-position}. Read-only.

Whether the entry contents can be edited.

Default value: True
@item @anchor{slot.entry.editable}editable. Type: @code{boolean}. Accessor: @anchor{fn.entry-editable}@code{entry-editable}.

False removes outside bevel from entry.

Default value: True
@item @anchor{slot.entry.has-frame}has-frame. Type: @code{boolean}. Accessor: @anchor{fn.entry-has-frame}@code{entry-has-frame}.

False removes outside bevel from entry.

Default value: True
@item @anchor{slot.entry.im-module}im-module. Type: @code{string}. Accessor: @anchor{fn.entry-im-module}@code{entry-im-module}.

Which IM (input method) module should be used for this entry. See @ref{i-m-context}.

Setting this to a non-NIL value overrides the system-wide IM module setting. See the @SlotRef{settings,gtk-im-module} property.

Default value: NIL
@item @anchor{slot.entry.inner-border}inner-border. Type: @ref{border}. Accessor: @anchor{fn.entry-inner-border}@code{entry-inner-border}.

Sets the text area's border between the text and the frame.

Since 2.10
@item @anchor{slot.entry.invisible-char}invisible-char. Type: @code{integer}. Accessor: @anchor{fn.entry-invisible-char}@code{entry-invisible-char}.

The character to use when masking entry contents (in "password mode").

Default value: '*'
@item @anchor{slot.entry.invisible-char-set}invisible-char-set. Type: @code{boolean}. Accessor: @anchor{fn.entry-invisible-char-set}@code{entry-invisible-char-set}.

Whether the invisible char has been set for the GtkEntry.

Default value: False
@item @anchor{slot.entry.layout}layout. Type: @code{PangoLayout}. Accessor: @anchor{fn.entry-layout}@code{entry-layout}. Read-only.

The PangoLayout used to display the entry. The layout is useful to e.g. convert text positions to pixel positions, in combination with @SlotRef{entry,layout-offset}.

Keep in mind that the layout text may contain a preedit string, so @ref{entry-layout-index-to-text-index} and @ref{entry-text-index-to-layout-index} are needed to convert byte indices in the layout to byte indices in the entry contents.
@item @anchor{slot.entry.layout-offset}layout-offset. Type: list of @code{integer}. Accessor: @anchor{fn.entry-layout-offset}@code{entry-layout-offset}. Read-only.

Obtains the position of the PangoLayout used to render text in the entry, in widget coordinates as the list of two integers - the x and y offsets. Useful if you want to line up the text in an entry with some other text, e.g. when using the entry to implement editable cells in a sheet widget.

Also useful to convert mouse events into coordinates inside the PangoLayout, e.g. to take some action if some part of the entry text is clicked.

Note that as the user scrolls around in the entry the offsets will change; you'll need to connect to the "notify::scroll-offset" signal to track this. Remember when using the PangoLayout functions you need to convert to and from pixels using PANGO_PIXELS() or PANGO_SCALE.

Keep in mind that the layout text may contain a preedit string, so @ref{entry-layout-index-to-text-index} and @ref{entry-text-index-to-layout-index} are needed to convert byte indices in the layout to byte indices in the entry contents.
@item @anchor{slot.entry.max-length}max-length. Type: @code{integer}. Accessor: @anchor{fn.entry-max-length}@code{entry-max-length}.

Maximum number of characters for this entry. Zero if no maximum.

Allowed values: [0,65535]

Default value: 0
@item @anchor{slot.entry.overwrite-mode}overwrite-mode. Type: @code{boolean}. Accessor: @anchor{fn.entry-overwrite-mode}@code{entry-overwrite-mode}.

If text is overwritten when typing in the GtkEntry.

Default value: False
@item @anchor{slot.entry.primary-icon-activatable}primary-icon-activatable. Type: @code{boolean}. Accessor: @anchor{fn.entry-primary-icon-activatable}@code{entry-primary-icon-activatable}.

Whether the primary icon is activatable.

GTK+ emits the @SignalRef{entry,icon-press} and @SignalRef{entry,icon-release} signals only on sensitive, activatable icons.

Sensitive, but non-activatable icons can be used for purely informational purposes.

Default value: False
@item @anchor{slot.entry.primary-icon-gicon}primary-icon-gicon. Type: @code{GIcon}. Accessor: @anchor{fn.entry-primary-icon-gicon}@code{entry-primary-icon-gicon}.

The GIcon to use for the primary icon for the entry. TODO: GIcon is not yet supported
@item @anchor{slot.entry.primary-icon-name}primary-icon-name. Type: @code{string}. Accessor: @anchor{fn.entry-primary-icon-name}@code{entry-primary-icon-name}.

The icon name to use for the primary icon for the entry.

Default value: NIL
@item @anchor{slot.entry.primary-icon-pixbuf}primary-icon-pixbuf. Type: @ref{pixbuf}. Accessor: @anchor{fn.entry-primary-icon-pixbuf}@code{entry-primary-icon-pixbuf}.

A pixbuf to use as the primary icon for the entry.
@item @anchor{slot.entry.primary-icon-sensitive}primary-icon-sensitive. Type: @code{boolean}. Accessor: @anchor{fn.entry-primary-icon-sensitive}@code{entry-primary-icon-sensitive}.

Whether the primary icon is sensitive.

An insensitive icon appears grayed out. GTK+ does not emit the @SignalRef{entry,icon-press} and @SignalRef{entry,icon-release} signals and does not allow DND from insensitive icons.

An icon should be set insensitive if the action that would trigger when clicked is currently not available.

Default value: True
@item @anchor{slot.entry.primary-icon-stock}primary-icon-stock. Type: @code{string}. Accessor: @anchor{fn.entry-primary-icon-stock}@code{entry-primary-icon-stock}.

The stock id to use for the primary icon for the entry.

Default value: NIL
@item @anchor{slot.entry.primary-icon-storage-type}primary-icon-storage-type. Type: @ref{image-type}. Accessor: @anchor{fn.entry-primary-icon-storage-type}@code{entry-primary-icon-storage-type}. Read-only.

The representation which is used for the primary icon of the entry.

Default value: @EnumVRef{image-type,empty}
@item @anchor{slot.entry.primary-icon-tooltip-markup}primary-icon-tooltip-markup. Type: @code{string}. Accessor: @anchor{fn.entry-primary-icon-tooltip-markup}@code{entry-primary-icon-tooltip-markup}.

The contents of the tooltip on the primary icon, which is marked up with the Pango text markup language.

Default value: NIL
@item @anchor{slot.entry.primary-icon-tooltip-text}primary-icon-tooltip-text. Type: @code{string}. Accessor: @anchor{fn.entry-primary-icon-tooltip-text}@code{entry-primary-icon-tooltip-text}.

The contents of the tooltip on the primary icon.

Default value: NIL
@item @anchor{slot.entry.progress-fraction}progress-fraction. Type: @code{double-float}. Accessor: @anchor{fn.entry-progress-fraction}@code{entry-progress-fraction}.

The current fraction of the task that's been completed.

Allowed values: [0,1]

Default value: 0
@item @anchor{slot.entry.progress-pulse-step}progress-pulse-step. Type: @code{double-float}. Accessor: @anchor{fn.entry-progress-pulse-step}@code{entry-progress-pulse-step}.

The fraction of total entry width to move the progress bouncing block for each call to gtk_entry_progress_pulse().

Allowed values: [0,1]

Default value: 0.1
@item @anchor{slot.entry.scroll-offset}scroll-offset. Type: @code{integer}. Accessor: @anchor{fn.entry-scroll-offset}@code{entry-scroll-offset}. Read-only.

Number of pixels of the entry scrolled off the screen to the left.

Allowed values: >= 0

Default value: 0
@item @anchor{slot.entry.secondary-icon-activatable}secondary-icon-activatable. Type: @code{boolean}. Accessor: @anchor{fn.entry-secondary-icon-activatable}@code{entry-secondary-icon-activatable}.

Whether the secondary icon is activatable.

GTK+ emits the @SignalRef{entry,icon-press} and @SignalRef{entry,icon-release} signals only on sensitive, activatable icons.

Sensitive, but non-activatable icons can be used for purely informational purposes.

Default value: False
@item @anchor{slot.entry.secondary-icon-gicon}secondary-icon-gicon. Type: @code{GIcon}. Accessor: @anchor{fn.entry-secondary-icon-gicon}@code{entry-secondary-icon-gicon}.

The GIcon to use for the secondary icon for the entry. TODO: GIcon is not yet supported
@item @anchor{slot.entry.secondary-icon-name}secondary-icon-name. Type: @code{string}. Accessor: @anchor{fn.entry-secondary-icon-name}@code{entry-secondary-icon-name}.

The icon name to use for the secondary icon for the entry.

Default value: NIL
@item @anchor{slot.entry.secondary-icon-pixbuf}secondary-icon-pixbuf. Type: @ref{pixbuf}. Accessor: @anchor{fn.entry-secondary-icon-pixbuf}@code{entry-secondary-icon-pixbuf}.

An pixbuf to use as the secondary icon for the entry.
@item @anchor{slot.entry.secondary-icon-sensitive}secondary-icon-sensitive. Type: @code{boolean}. Accessor: @anchor{fn.entry-secondary-icon-sensitive}@code{entry-secondary-icon-sensitive}.

Whether the secondary icon is sensitive.

An insensitive icon appears grayed out. GTK+ does not emit the @SignalRef{entry,icon-press} and @SignalRef{entry,icon-release} signals and does not allow DND from insensitive icons.

An icon should be set insensitive if the action that would trigger when clicked is currently not available.

Default value: True
@item @anchor{slot.entry.secondary-icon-stock}secondary-icon-stock. Type: @code{string}. Accessor: @anchor{fn.entry-secondary-icon-stock}@code{entry-secondary-icon-stock}.

The stock id to use for the secondary icon for the entry.

Default value: NIL
@item @anchor{slot.entry.secondary-icon-storage-type}secondary-icon-storage-type. Type: @ref{image-type}. Accessor: @anchor{fn.entry-secondary-icon-storage-type}@code{entry-secondary-icon-storage-type}. Read-only.

The representation which is used for the secondary icon of the entry.

Default value: @EnumVRef{image-type,empty}
@item @anchor{slot.entry.secondary-icon-tooltip-markup}secondary-icon-tooltip-markup. Type: @code{string}. Accessor: @anchor{fn.entry-secondary-icon-tooltip-markup}@code{entry-secondary-icon-tooltip-markup}.

The contents of the tooltip on the secondary icon, which is marked up with the Pango text markup language.

Default value: NIL
@item @anchor{slot.entry.secondary-icon-tooltip-text}secondary-icon-tooltip-text. Type: @code{string}. Accessor: @anchor{fn.entry-secondary-icon-tooltip-text}@code{entry-secondary-icon-tooltip-text}.

The contents of the tooltip on the secondary icon.

Default value: NIL
@item @anchor{slot.entry.selection-bound}selection-bound. Type: @code{integer}. Accessor: @anchor{fn.entry-selection-bound}@code{entry-selection-bound}. Read-only.

The position of the opposite end of the selection from the cursor in chars.

Allowed values: [0,65535]

Default value: 0
@item @anchor{slot.entry.shadow-type}shadow-type. Type: @ref{shadow-type}. Accessor: @anchor{fn.entry-shadow-type}@code{entry-shadow-type}.

Which kind of shadow to draw around the entry when "has-frame" is set to True.

Default value: @EnumVRef{shadow-type,in}
@item @anchor{slot.entry.text}text. Type: @code{string}. Accessor: @anchor{fn.entry-text}@code{entry-text}.

The contents of the entry.

Default value: ""
@item @anchor{slot.entry.text-length}text-length. Type: @code{integer}. Accessor: @anchor{fn.entry-text-length}@code{entry-text-length}. Read-only.

The length of the text in the GtkEntry.

Allowed values: <= 65535

Default value: 0
@item @anchor{slot.entry.truncate-multiline}truncate-multiline. Type: @code{boolean}. Accessor: @anchor{fn.entry-truncate-multiline}@code{entry-truncate-multiline}.

When True, pasted multi-line text is truncated to the first line.

Default value: False
@item @anchor{slot.entry.visibility}visibility. Type: @code{boolean}. Accessor: @anchor{fn.entry-visibility}@code{entry-visibility}.

False displays the "invisible char" instead of the actual text (password mode).

Default value: True
@item @anchor{slot.entry.width-chars}width-chars. Type: @code{integer}. Accessor: @anchor{fn.entry-width-chars}@code{entry-width-chars}.

Number of characters to leave space for in the entry.

Default value: -1
@item @anchor{slot.entry.xalign}xalign. Type: @code{single-float}. Accessor: @anchor{fn.entry-xalign}@code{entry-xalign}.

The horizontal alignment, from 0 (left) to 1 (right). Reversed for RTL layouts.

Allowed values: [0,1]

Default value: 0
@end itemize

Signals:
@itemize
@item @anchor{signal.entry.activate}"activate". Signature: (instance @ref{entry}) @result{} void. Options: run-last, action.

A keybinding signal which gets emitted when the user activates the entry.

Applications should not connect to it, but may emit it with @ref{emit-signal} if they need to control activation programmatically.

The default bindings for this signal are all forms of the Enter key.
@item @anchor{signal.entry.backspace}"backspace". Signature: (instance @ref{entry}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted when the user asks for it.

The default bindings for this signal are Backspace and Shift-Backspace.
@item @anchor{signal.entry.copy-clipboard}"copy-clipboard". Signature: (instance @ref{entry}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted to copy the selection to the clipboard.

The default bindings for this signal are Ctrl-c and Ctrl-Insert.
@item @anchor{signal.entry.cut-clipboard}"cut-clipboard". Signature: (instance @ref{entry}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted to cut the selection to the clipboard.

The default bindings for this signal are Ctrl-x and Shift-Delete.
@item @anchor{signal.entry.delete-from-cursor}"delete-from-cursor". Signature: (instance @ref{entry}), (type @ref{delete-type}), (count @code{integer}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted when the user initiates a text deletion.

If the @var{type} is @EnumVRef{delete-type,chars}, GTK+ deletes the selection if there is one, otherwise it deletes the requested number of characters.

The default bindings for this signal are Delete for deleting a character and Ctrl-Delete for deleting a word.

@var{count} is the number of type units to delete
@item @anchor{signal.entry.icon-press}"icon-press". Signature: (instance @ref{entry}), (icon @ref{entry-icon-position}), (event @ref{event}) @result{} void. Options: run-last.

This signal is emitted when an activatable icon is clicked.
@item @anchor{signal.entry.icon-release}"icon-release". Signature: (instance @ref{entry}), (icon @code{entry-icon-position}), (event @ref{event}) @result{} void. Options: run-last.

This signal is emitted on the button release from a mouse click over an activatable icon.
@item @anchor{signal.entry.insert-at-cursor}"insert-at-cursor". Signature: (instance @ref{entry}), (string @code{string}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted when the user initiates the insertion of a fixed string at the cursor.

This signal has no default bindings.
@item @anchor{signal.entry.move-cursor}"move-cursor". Signature: (instance @ref{entry}), (step @ref{movement-step}), (count @code{integer}), (extend-selection @code{boolean}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted when the user initiates a cursor movement. If the cursor is not visible in entry, this signal causes the viewport to be moved instead.

Applications should not connect to it, but may emit it with @ref{emit-signal} if they need to control the cursor programmatically.

The default bindings for this signal come in two variants, the variant with the Shift modifier extends the selection, the variant without the Shift modifer does not. There are too many key combinations to list them all here.

@itemize
@item Arrow keys move by individual characters/lines
@item Ctrl-arrow key combinations move by words/paragraphs
@item Home/End keys move to the ends of the buffer
@end itemize

@var{count} is the number of @var{step} units to move

@var{extend-selection} is True if the move should extend the selection
@item @anchor{signal.entry.paste-clipboard}"paste-clipboard". Signature: (instance @ref{entry}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted to paste the contents of the clipboard into the text view.

The default bindings for this signal are Ctrl-v and Shift-Insert.
@item @anchor{signal.entry.populate-popup}"populate-popup". Signature: (instance @ref{entry}), (menu @ref{menu}) @result{} void. Options: run-last.

This signal gets emitted before showing the context menu of the entry.

If you need to add items to the context menu, connect to this signal and append your menuitems to the menu.
@item @anchor{signal.entry.toggle-overwrite}"toggle-overwrite". Signature: (instance @ref{entry}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted to toggle the overwrite mode of the entry.

The default bindings for this signal is Insert.
@end itemize

@RMethod entry-layout-index-to-text-index
@lisp
(entry-layout-index-to-text-index entry layout-index) @result{} text-index
@end lisp

Converts from a position in the entry contents to a position in the entry's PangoLayout.

@var{layout-index} - byte index into the entry layout text

@var{text-index} - byte index into the entry contents

@RMethod entry-text-index-to-layout-index
@lisp
(entry-text-index-to-layout-index entry text-index) @result{} layout-index
@end lisp

Converts from a position in the entry's PangoLayout contents to a position in the entry.

@var{layout-index} - byte index into the entry layout text

@var{text-index} - byte index into the entry contents

@node event-box
@section event-box
@Class event-box
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.event-box.above-child}above-child. Type: @code{boolean}. Accessor: @anchor{fn.event-box-above-child}@code{event-box-above-child}.
@item @anchor{slot.event-box.visible-window}visible-window. Type: @code{boolean}. Accessor: @anchor{fn.event-box-visible-window}@code{event-box-visible-window}.
@end itemize


Signals:
@itemize
@end itemize




@node expander
@section expander
@Class expander
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.expander.expanded}expanded. Type: @code{boolean}. Accessor: @anchor{fn.expander-expanded}@code{expander-expanded}.
@item @anchor{slot.expander.label}label. Type: @code{string}. Accessor: @anchor{fn.expander-label}@code{expander-label}.
@item @anchor{slot.expander.label-widget}label-widget. Type: @ref{widget}. Accessor: @anchor{fn.expander-label-widget}@code{expander-label-widget}.
@item @anchor{slot.expander.spacing}spacing. Type: @code{integer}. Accessor: @anchor{fn.expander-spacing}@code{expander-spacing}.
@item @anchor{slot.expander.use-markup}use-markup. Type: @code{boolean}. Accessor: @anchor{fn.expander-use-markup}@code{expander-use-markup}.
@item @anchor{slot.expander.use-underline}use-underline. Type: @code{boolean}. Accessor: @anchor{fn.expander-use-underline}@code{expander-use-underline}.
@end itemize


Signals:
@itemize
@item @anchor{signal.expander.activate}"activate". Signature: (instance @ref{expander}) @result{} void. Options: run-last, action.
@end itemize




@node file-chooser-button
@section file-chooser-button
@Class file-chooser-button
Superclass: @ref{h-box} @ref{atk-implementor-iface} @ref{buildable} @ref{file-chooser} @ref{orientable}

Slots:
@itemize
@item @anchor{slot.file-chooser-button.dialog}dialog. Type: @ref{file-chooser}. Accessor: @anchor{fn.file-chooser-button-dialog}@code{file-chooser-button-dialog}. Write-only.
@item @anchor{slot.file-chooser-button.focus-on-click}focus-on-click. Type: @code{boolean}. Accessor: @anchor{fn.file-chooser-button-focus-on-click}@code{file-chooser-button-focus-on-click}.
@item @anchor{slot.file-chooser-button.title}title. Type: @code{string}. Accessor: @anchor{fn.file-chooser-button-title}@code{file-chooser-button-title}.
@item @anchor{slot.file-chooser-button.width-chars}width-chars. Type: @code{integer}. Accessor: @anchor{fn.file-chooser-button-width-chars}@code{file-chooser-button-width-chars}.
@end itemize


Signals:
@itemize
@item @anchor{signal.file-chooser-button.file-set}"file-set". Signature: (instance @ref{file-chooser-button}) @result{} void. Options: run-first.
@end itemize




@node file-chooser-dialog
@section file-chooser-dialog
@Class file-chooser-dialog
Superclass: @ref{dialog} @ref{atk-implementor-iface} @ref{buildable} @ref{file-chooser}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node file-chooser-widget
@section file-chooser-widget
@Class file-chooser-widget
Superclass: @ref{v-box} @ref{atk-implementor-iface} @ref{buildable} @ref{file-chooser} @ref{file-chooser-embed} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node fixed
@section fixed
@Class fixed
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.fixed.has-window}has-window. Type: @code{boolean}. Accessor: @anchor{fn.fixed-has-window}@code{fixed-has-window}.
@end itemize


Signals:
@itemize
@end itemize




@node font-button
@section font-button
@Class font-button
Superclass: @ref{button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.font-button.font-name}font-name. Type: @code{string}. Accessor: @anchor{fn.font-button-font-name}@code{font-button-font-name}.
@item @anchor{slot.font-button.show-size}show-size. Type: @code{boolean}. Accessor: @anchor{fn.font-button-show-size}@code{font-button-show-size}.
@item @anchor{slot.font-button.show-style}show-style. Type: @code{boolean}. Accessor: @anchor{fn.font-button-show-style}@code{font-button-show-style}.
@item @anchor{slot.font-button.title}title. Type: @code{string}. Accessor: @anchor{fn.font-button-title}@code{font-button-title}.
@item @anchor{slot.font-button.use-font}use-font. Type: @code{boolean}. Accessor: @anchor{fn.font-button-use-font}@code{font-button-use-font}.
@item @anchor{slot.font-button.use-size}use-size. Type: @code{boolean}. Accessor: @anchor{fn.font-button-use-size}@code{font-button-use-size}.
@end itemize


Signals:
@itemize
@item @anchor{signal.font-button.font-set}"font-set". Signature: (instance @ref{font-button}) @result{} void. Options: run-first.
@end itemize




@node font-selection
@section font-selection
@Class font-selection
Superclass: @ref{v-box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@item @anchor{slot.font-selection.font}font. Type: @ref{font}. Accessor: @anchor{fn.font-selection-font}@code{font-selection-font}. Read-only.
@item @anchor{slot.font-selection.font-name}font-name. Type: @code{string}. Accessor: @anchor{fn.font-selection-font-name}@code{font-selection-font-name}.
@item @anchor{slot.font-selection.preview-text}preview-text. Type: @code{string}. Accessor: @anchor{fn.font-selection-preview-text}@code{font-selection-preview-text}.
@end itemize


Signals:
@itemize
@end itemize




@node font-selection-dialog
@section font-selection-dialog
@Class font-selection-dialog
Superclass: @ref{dialog} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.font-selection-dialog.apply-button}apply-button. Type: @ref{g-object}. Accessor: @anchor{fn.font-selection-dialog-apply-button}@code{font-selection-dialog-apply-button}. Read-only.
@item @anchor{slot.font-selection-dialog.cancel-button}cancel-button. Type: @ref{g-object}. Accessor: @anchor{fn.font-selection-dialog-cancel-button}@code{font-selection-dialog-cancel-button}. Read-only.
@item @anchor{slot.font-selection-dialog.font-name}font-name. Type: @code{string}. Accessor: @anchor{fn.font-selection-dialog-font-name}@code{font-selection-dialog-font-name}.
@item @anchor{slot.font-selection-dialog.ok-button}ok-button. Type: @ref{g-object}. Accessor: @anchor{fn.font-selection-dialog-ok-button}@code{font-selection-dialog-ok-button}. Read-only.
@item @anchor{slot.font-selection-dialog.preview-text}preview-text. Type: @code{string}. Accessor: @anchor{fn.font-selection-dialog-preview-text}@code{font-selection-dialog-preview-text}.
@end itemize


Signals:
@itemize
@end itemize




@node frame
@section frame
@Class frame
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{aspect-frame}

Slots:
@itemize
@item @anchor{slot.frame.label}label. Type: @code{string}. Accessor: @anchor{fn.frame-label}@code{frame-label}.
@item @anchor{slot.frame.label-widget}label-widget. Type: @ref{widget}. Accessor: @anchor{fn.frame-label-widget}@code{frame-label-widget}.
@item @anchor{slot.frame.label-xalign}label-xalign. Type: @code{single-float}. Accessor: @anchor{fn.frame-label-xalign}@code{frame-label-xalign}.
@item @anchor{slot.frame.label-yalign}label-yalign. Type: @code{single-float}. Accessor: @anchor{fn.frame-label-yalign}@code{frame-label-yalign}.
@item @anchor{slot.frame.shadow}shadow. Type: @ref{shadow-type}. Accessor: @anchor{fn.frame-shadow}@code{frame-shadow}.
@item @anchor{slot.frame.shadow-type}shadow-type. Type: @ref{shadow-type}. Accessor: @anchor{fn.frame-shadow-type}@code{frame-shadow-type}.
@end itemize


Signals:
@itemize
@end itemize




@node gamma-curve
@section gamma-curve
@Class gamma-curve
Superclass: @ref{v-box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node gtk-window
@section gtk-window
@Class gtk-window
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{plug} @ref{assistant} @ref{dialog}

@ref{gtk-window} is a toplevel window that can contain other widgets. Nearly always, the type of the window should be @EnumVRef{window-type,toplevel}. If you're implementing something like a popup menu from scratch (which is a bad idea, just use @ref{menu}), you might use @EnumVRef{window-type,popup}. @EnumVRef{window-type,popup} is not for dialogs, though in some other toolkits dialogs are called "popups". In GTK+, @EnumVRef{window-type,popup} means a pop-up menu or pop-up tooltip. On X11, popup windows are not controlled by the window manager.

If you simply want an undecorated window (no window borders), use @SlotRef{gtk-window,decorated}, don't use @EnumVRef{window-type,popup}.

Slots:
@itemize
@item @anchor{slot.gtk-window.accept-focus}accept-focus. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-accept-focus}@code{gtk-window-accept-focus}.

Windows may set a hint asking the desktop environment not to receive the input focus. True if the window should receive the input focus.

Default value: True
@item @anchor{slot.gtk-window.allow-grow}allow-grow. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-allow-grow}@code{gtk-window-allow-grow}.

If True, users can expand the window beyond its minimum size.

Default value: True
@item @anchor{slot.gtk-window.allow-shrink}allow-shrink. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-allow-shrink}@code{gtk-window-allow-shrink}.

If True, the window has no mimimum size. Setting this to True is 99% of the time a bad idea.

Default value: False
@item @anchor{slot.gtk-window.decorated}decorated. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-decorated}@code{gtk-window-decorated}.

Whether the window should be decorated by the window manager.

By default, windows are decorated with a title bar, resize controls, etc. Some window managers allow GTK+ to disable these decorations, creating a borderless window. If you set the decorated property to False using this function, GTK+ will do its best to convince the window manager not to decorate the window. Depending on the system, this function may not have any effect when called on a window that is already visible, so you should call it before calling @ref{widget-show}.

On Windows, this always works, since there's no window manager policy involved.

Default value: True

@item @anchor{slot.gtk-window.default-height}default-height. Type: @code{integer}. Accessor: @anchor{fn.gtk-window-default-height}@code{gtk-window-default-height}.

The default height of the window, used when initially showing the window.

If the window's "natural" size (its size request) is larger than the default, the default will be ignored. More generally, if the default size does not obey the geometry hints for the window (@ref{gtk-window-set-geometry-hints} can be used to set these explicitly), the default size will be clamped to the nearest permitted size.

Unlike @SlotRef{widget,width-request} and @SlotRef{widget,height-request}, that set a size request for a widget and thus would keep users from shrinking the window, this function only sets the initial size, just as if the user had resized the window themselves. Users can still shrink the window again as they normally would. Setting a default size of -1 means to use the "natural" default size (the size request of the window).

For more control over a window's initial size and how resizing works, see @ref{gtk-window-set-geometry-hints}.

For some uses, @ref{gtk-window-resize} is a more appropriate function. @ref{gtk-window-resize} changes the current size of the window, rather than the size to be used on initial display. @ref{gtk-window-resize} always affects the window itself, not the geometry widget.

The default size of a window only affects the first time a window is shown; if a window is hidden and re-shown, it will remember the size it had prior to hiding, rather than using the default size.

Windows can't actually be 0x0 in size, they must be at least 1x1, but passing 0 for width and height is OK, resulting in a 1x1 default size.

Default value: -1
@item @anchor{slot.gtk-window.default-widget}default-widget. Type: @ref{widget}. Accessor: @anchor{fn.gtk-window-default-widget}@code{gtk-window-default-widget}.

The default widget is the widget that's activated when the user presses Enter in a dialog (for example). When setting (rather than unsetting) the default widget it's generally easier to call gtk_widget_grab_focus() on the widget. Before making a widget the default widget, you must set the @SlotRef{widget,can-default} on the widget you'd like to make the default.
@item @anchor{slot.gtk-window.default-width}default-width. Type: @code{integer}. Accessor: @anchor{fn.gtk-window-default-width}@code{gtk-window-default-width}.

The default width of the window, used when initially showing the window.

See @SlotRef{gtk-window,default-height} for explanation.

Default value: -1
@item @anchor{slot.gtk-window.deletable}deletable. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-deletable}@code{gtk-window-deletable}.

Whether the window frame should have a close button.

By default, windows have a close button in the window frame. Some window managers allow GTK+ to disable this button. If you set the deletable property to False using this function, GTK+ will do its best to convince the window manager not to show a close button. Depending on the system, this function may not have any effect when called on a window that is already visible, so you should call it before calling @ref{widget-show}.

On Windows, this always works, since there's no window manager policy involved.

Default value: True
@item @anchor{slot.gtk-window.destroy-with-parent}destroy-with-parent. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-destroy-with-parent}@code{gtk-window-destroy-with-parent}.

If this window should be destroyed when the parent is destroyed.

Default value: False
@item @anchor{slot.gtk-window.focus}focus. Type: @ref{widget}. Accessor: @anchor{fn.gtk-window-focus}@code{gtk-window-focus}.

The current focused widget within the window. Note that this is the widget that would have the focus if the toplevel window focused; if the toplevel window is not focused then @SlotRef{gtk-window,focus} will not be True for the widget.

Settings this works the following way. If focus is not the current focus widget, and is focusable, sets it as the focus widget for the window. If focus is NIL, unsets the focus widget for this window. To set the focus to a particular widget in the toplevel, it is usually more convenient to use @ref{widget-grab-focus} instead of this function.

@item @anchor{slot.gtk-window.focus-on-map}focus-on-map. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-focus-on-map}@code{gtk-window-focus-on-map}.

Windows may set a hint asking the desktop environment not to receive the input focus when the window is mapped.  True if the window should receive the input focus when mapped.

Default value: True
@item @anchor{slot.gtk-window.group}group. Type: @ref{window-group}. Accessor: @anchor{fn.gtk-window-group}@code{gtk-window-group}. Read-only.

Returns the group for window or the default group, if window does not have an explicit window group.
@item @anchor{slot.gtk-window.gravity}gravity. Type: @ref{gravity}. Accessor: @anchor{fn.gtk-window-gravity}@code{gtk-window-gravity}.

The window gravity of the window. See @ref{gtk-window-move} and @ref{gravity} for more details about window gravity.

Default value: @EnumVRef{anchor-type,north-west}

@item @anchor{slot.gtk-window.has-frame}has-frame. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-has-frame}@code{gtk-window-has-frame}.

(Note: this is a special-purpose property for the framebuffer port that causes GTK+ to draw its own window border. For most applications you want @SlotRef{gtk-window,decorated} instead, which tells the window manager whether to draw the window border.)

If this property is set to True on a window, then before it is realized or showed, it will have a "frame" window around @SlotRef{widget,window}. Using the signal @SignalRef{gtk-window,frame-event} you can receive all events targeted at the frame.

This function is used by the linux-fb port to implement managed windows, but it could conceivably be used by X-programs that want to do their own window decorations.
@item @anchor{slot.gtk-window.has-toplevel-focus}has-toplevel-focus. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-has-toplevel-focus}@code{gtk-window-has-toplevel-focus}. Read-only.

Whether the input focus is within this GtkWindow.

Default value: False
@item @anchor{slot.gtk-window.icon}icon. Type: @ref{pixbuf}. Accessor: @anchor{fn.gtk-window-icon}@code{gtk-window-icon}.

This icon is used when the window is minimized (also known as iconified). Some window managers or desktop environments may also place it in the window frame, or display it in other contexts.

The icon should be provided in whatever size it was naturally drawn; that is, don't scale the image before passing it to GTK+. Scaling is postponed until the last minute, when the desired final size is known, to allow best quality.

Icon for this window.
@item @anchor{slot.gtk-window.icon-list}icon-list. Type: list of @ref{pixbuf}. Accessor: @anchor{fn.gtk-window-icon-list}@code{gtk-window-icon-list}.

The icon representing a @ref{gtk-window}. The icon is used when the window is minimized (also known as iconified). Some window managers or desktop environments may also place it in the window frame, or display it in other contexts.

This property allows you to pass in the same icon in several hand-drawn sizes. The list should contain the natural sizes your icon is available in; that is, don't scale the image before passing it to GTK+. Scaling is postponed until the last minute, when the desired final size is known, to allow best quality.

By passing several sizes, you may improve the final image quality of the icon, by reducing or eliminating automatic image scaling.

Recommended sizes to provide: 16x16, 32x32, 48x48 at minimum, and larger images (64x64, 128x128) if you have them.

See also @ref{gtk-window-default-icon-list} to set the icon for all windows in your application in one go.

Note that transient windows (those who have been set transient for another window using @SlotRef{gtk-window,transient-for}) will inherit their icon from their transient parent. So there's no need to explicitly set the icon on transient windows.

@item @anchor{slot.gtk-window.icon-name}icon-name. Type: @code{string}. Accessor: @anchor{fn.gtk-window-icon-name}@code{gtk-window-icon-name}.

The icon-name property specifies the name of the themed icon to use as the window icon. See @ref{icon-theme} for more details.

Note that this has nothing to do with the WM_ICON_NAME property which is mentioned in the ICCCM.

Default value: NIL
@item @anchor{slot.gtk-window.is-active}is-active. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-is-active}@code{gtk-window-is-active}. Read-only.

Whether the toplevel is the current active window.

Default value: False
@item @anchor{slot.gtk-window.keep-above}keep-above. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-keep-above}@code{gtk-window-keep-above}. Write-only.

Setting this to True asks to keep window above, so that it stays on top. Note that you shouldn't assume the window is definitely above afterward, because other entities (e.g. the user or window manager) could not keep it above, and not all window managers support keeping windows above. But normally the window will end kept above. Just don't write code that crashes if not.

It's permitted to set this property before showing a window, in which case the window will be kept above when it appears onscreen initially.

You can track the above state via the @SignalRef{widget,window-state-event} signal.

Note that, according to the Extended Window Manager Hints specification, the above state is mainly meant for user preferences and should not be used by applications e.g. for drawing attention to their dialogs.
@item @anchor{slot.gtk-window.keep-below}keep-below. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-keep-below}@code{gtk-window-keep-below}. Write-only.

Setting this to True asks to keep window below, so that it stays in bottom. Note that you shouldn't assume the window is definitely below afterward, because other entities (e.g. the user or window manager) could not keep it below, and not all window managers support putting windows below. But normally the window will be kept below. Just don't write code that crashes if not.

It's permitted to set this property before showing a window, in which case the window will be kept below when it appears onscreen initially.

You can track the below state via the @SignalRef{widget,window-state-event} signal.

Note that, according to the Extended Window Manager Hints specification, the above state is mainly meant for user preferences and should not be used by applications e.g. for drawing attention to their dialogs.
@item @anchor{slot.gtk-window.mnemonic-modifier}mnemonic-modifier. Type: @ref{modifier-type}. Accessor: @anchor{fn.gtk-window-mnemonic-modifier}@code{gtk-window-mnemonic-modifier}.

The modifier mask used to activate mnemonics on this window.
@item @anchor{slot.gtk-window.modal}modal. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-modal}@code{gtk-window-modal}.

If True, the window is modal (other windows are not usable while this one is up).

Default value: False
@item @anchor{slot.gtk-window.opacity}opacity. Type: @code{double-float}. Accessor: @anchor{fn.gtk-window-opacity}@code{gtk-window-opacity}.

The requested opacity of the window.

Setting opacity requests the windowing system to make window partially transparent, with opacity 0 being fully transparent and 1 fully opaque. (Values of the opacity parameter are clamped to the [0,1] range.) On X11 this has any effect only on X screens with a compositing manager running. See @SlotRef{screen,composited-p}. On Windows it should work always.

Note that setting a window's opacity after the window has been shown causes it to flicker once on Windows.

Allowed values: [0,1]

Default value: 1
@item @anchor{slot.gtk-window.resizable}resizable. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-resizable}@code{gtk-window-resizable}.

If True, users can resize the window.

Default value: True
@item @anchor{slot.gtk-window.role}role. Type: @code{string}. Accessor: @anchor{fn.gtk-window-role}@code{gtk-window-role}.

Unique identifier for the window to be used when restoring a session.

This is only useful on X11, not with other GTK+ targets.

In combination with the window title, the window role allows a window manager to identify "the same" window when an application is restarted. So for example you might set the "toolbox" role on your app's toolbox window, so that when the user restarts their session, the window manager can put the toolbox back in the same place.

If a window already has a unique title, you don't need to set the role, since the WM can use the title to identify the window when restoring the session.

Default value: NIL
@item @anchor{slot.gtk-window.screen}screen. Type: @ref{screen}. Accessor: @anchor{fn.gtk-window-screen}@code{gtk-window-screen}.

The screen where this window will be displayed.
@item @anchor{slot.gtk-window.skip-pager-hint}skip-pager-hint. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-skip-pager-hint}@code{gtk-window-skip-pager-hint}.

Windows may set a hint asking the desktop environment not to display the window in the pager. (A "pager" is any desktop navigation tool such as a workspace switcher that displays a thumbnail representation of the windows on the screen.) True if the window should not be in the pager.

Default value: False
@item @anchor{slot.gtk-window.skip-taskbar-hint}skip-taskbar-hint. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-skip-taskbar-hint}@code{gtk-window-skip-taskbar-hint}.

Windows may set a hint asking the desktop environment not to display the window in the task bar. True if the window should not be in the task bar.

Default value: False
@item @anchor{slot.gtk-window.startup-id}startup-id. Type: @code{string}. Accessor: @anchor{fn.gtk-window-startup-id}@code{gtk-window-startup-id}. Write-only.

The startup-id is a write-only property for setting window's startup notification identifier.

Startup notification identifiers are used by desktop environment to track application startup, to provide user feedback and other features. This function changes the corresponding property on the underlying @ref{gdk-window}. Normally, startup identifier is managed automatically and you should only use this function in special cases like transferring focus from other processes. You should set this before calling @ref{gtk-window-present} or any equivalent function generating a window map event.

This is only useful on X11, not with other GTK+ targets.

Default value: NIL
@item @anchor{slot.gtk-window.title}title. Type: @code{string}. Accessor: @anchor{fn.gtk-window-title}@code{gtk-window-title}.

The title of the window.

Default value: NIL
@item @anchor{slot.gtk-window.transient-for}transient-for. Type: @ref{gtk-window}. Accessor: @anchor{fn.gtk-window-transient-for}@code{gtk-window-transient-for}.

The transient parent of the window.

Dialog windows should be set transient for the main application window they were spawned from. This allows window managers to e.g. keep the dialog on top of the main window, or center the dialog over the main window.

On Windows, this puts the child window on top of the parent, much as the window manager would have done on X.
@item @anchor{slot.gtk-window.type}type. Type: @ref{window-type}. Accessor: @anchor{fn.gtk-window-type}@code{gtk-window-type}.

The type of the window.

Default value: @EnumVRef{window-type,toplevel}
@item @anchor{slot.gtk-window.type-hint}type-hint. Type: @ref{gdk-window-type-hint}. Accessor: @anchor{fn.gtk-window-type-hint}@code{gtk-window-type-hint}.

Hint to help the desktop environment understand what kind of window this is and how to treat it.

This should be set before the window becomes visible.

Default value: @EnumVRef{gdk-window-type-hint,normal}
@item @anchor{slot.gtk-window.urgency-hint}urgency-hint. Type: @code{boolean}. Accessor: @anchor{fn.gtk-window-urgency-hint}@code{gtk-window-urgency-hint}.

Windows may set a hint asking the desktop environment to draw the users attention to the window. True if the window should be brought to the user's attention.

Default value: False
@item @anchor{slot.gtk-window.window-position}window-position. Type: @ref{window-position}. Accessor: @anchor{fn.gtk-window-window-position}@code{gtk-window-window-position}.

The initial position of the window.

Default value: @EnumVRef{window-position,none}
@end itemize


Signals:
@itemize
@item @anchor{signal.gtk-window.activate-default}"activate-default". Signature: (instance @ref{gtk-window}) @result{} void. Options: run-last, action.

The activate-default signal is a keybinding signal which gets emitted when the user activates the default widget of window.
@item @anchor{signal.gtk-window.activate-focus}"activate-focus". Signature: (instance @ref{gtk-window}) @result{} void. Options: run-last, action.

The activate-default signal is a keybinding signal which gets emitted when the user activates the currently focused widget of window.
@item @anchor{signal.gtk-window.frame-event}"frame-event". Signature: (instance @ref{gtk-window}), (event @ref{event}) @result{} @code{boolean}. Options: run-last.


@item @anchor{signal.gtk-window.keys-changed}"keys-changed". Signature: (instance @ref{gtk-window}) @result{} void. Options: run-first.

The keys-changed signal gets emitted when the set of accelerators or mnemonics that are associated with window changes.
@item @anchor{signal.gtk-window.set-focus}"set-focus". Signature: (instance @ref{gtk-window}), (widget @ref{widget}) @result{} void. Options: run-last.
@end itemize

@RMethod gtk-window-add-accel-group
@lisp
(gtk-window-add-accel-group window accel-group)
@end lisp

Associate @var{accel-group} (an @ref{accel-group}) with @var{window} (an @ref{gtk-window}).

@RMethod gtk-window-remove-accel-group
@lisp
(gtk-window-remove-accel-group window accel-group)
@end lisp

Reverses the effect of @ref{gtk-window-add-accel-group}.

@RMethod gtk-window-activate-focus
@lisp
(gtk-window-activate-focus window)
@end lisp

Activates the current focused widget within the @var{window} (an @ref{gtk-window}).

@RMethod gtk-window-activate-default
@lisp
(gtk-window-activate-default window) @result{} activated-p
@end lisp

Activates the default widget for the @var{window} (an @ref{gtk-window}), unless the current focused widget has been configured to receive the default action (see @SlotRef{widget,receives-default}), in which case the focused widget is activated.

Returns True if a widget got activated.

@RMethod gtk-window-set-geometry-hints
@lisp
(gtk-window-set-geometry-hints window geometry-widget geometry geometry-mask)
@end lisp

This function sets up hints about how a @var{window} (an @ref{gtk-window}) can be resized by the user. You can set a minimum and maximum size; allowed resize increments (e.g. for xterm, you can only resize by the size of a character); aspect ratios; and more. See the @ref{geometry} struct.

@var{geometry-widget}: a @ref{widget} - widget the geometry hints will be applied to

@var{geometry}: a @ref{geometry} - struct containing geometry information

@var{geometry-mask}: a @ref{window-hints} - mask indicating which struct fields should be paid attention to

@RFunction gtk-window-list-toplevels
@lisp
(gtk-window-list-toplevels) @result{} windows
@end lisp

Returns a list of all existing toplevel windows. The widgets in the list are not individually referenced.

@var{windows}: fresh list of @ref{gtk-window}

@RMethod gtk-window-add-mnemonic
@lisp
(window-add-mnemonic window keyval target)
@end lisp

Adds a mnemonic to this @var{window} (a @ref{gtk-window}).

@var{keyval}: mnemonic keyval

@var{target}: the @ref{widget} that gets activated by the mnemonic

@RMethod gtk-window-remove-mnemonic
@lisp
(gtk-window-remove-mnemonic window keyval target)
@end lisp

Removes a mnemonic from this @var{window} (a @ref{gtk-window}).

@var{keyval}: mnemonic keyval

@var{target}: the @ref{widget} that gets activated by the mnemonic

@RMethod gtk-window-activate-mnemonic
@lisp
(gtk-window-activate-mnemonic window keyval modifier)
@end lisp

Activates the targets associated with the mnemonic.

@var{keyval}: mnemonic keyval

@var{modifier}: a @ref{modifier-type} - modifiers

@RMethod gtk-window-activate-key
@lisp
(gtk-window-activate-key window event) @result{} activated-p
@end lisp

Activates mnemonics and accelerators for this @ref{gtk-window}. This is normally called by the default @SignalRef{widget,key-press-event} handler for toplevel windows, however in some cases it may be useful to call this directly when overriding the standard key handling for a toplevel window.

Returns True if a mnemonic or accelerator was found and activated.

@var{event}: a @ref{event-key}

@RMethod gtk-window-propagate-key-event
@lisp
(gtk-window-propagate-key-event window event) @result{} handled-p
@end lisp

Propagate a key press or release event to the focus widget and up the focus container chain until a widget handles @var{event}. This is normally called by the default @SignalRef{widget,key-press-event} and @SignalRef{widget,key-release-event} handlers for toplevel windows, however in some cases it may be useful to call this directly when overriding the standard key handling for a toplevel window.

Returns True if a widget in the focus chain handled the event.

@var{event}: a @ref{event-key}

@RMethod gtk-window-present
@lisp
(gtk-window-present window)
@end lisp

Presents a @var{window} (a @ref{gtk-window}) to the user. This may mean raising the window in the stacking order, deiconifying it, moving it to the current desktop, and/or giving it the keyboard focus, possibly dependent on the user's platform, window manager, and preferences.

If window is hidden, this function calls @ref{widget-show} as well.

This function should be used when the user tries to open a window that's already open. Say for example the preferences dialog is currently open, and the user chooses Preferences from the menu a second time; use @ref{gtk-window-present} to move the already-open dialog where the user can see it.

If you are calling this function in response to a user interaction, it is preferable to use @ref{gtk-window-present-with-time}.

@RMethod gtk-window-present-with-time
@lisp
(gtk-window-present-with-time window timestamp)
@end lisp

Presents a @var{window} (a @ref{gtk-window}) to the user in response to a user interaction. If you need to present a window without a timestamp, use @ref{gtk-window-present}. See @ref{gtk-window-present} for details.

@var{timestamp}: the timestamp of the user interaction (typically a button or key press event) which triggered this call

@RMethod gtk-window-iconify
@lisp
(gtk-window-iconify window)
@end lisp

Asks to iconify (i.e. minimize) the specified @var{window} (a @ref{gtk-window}). Note that you shouldn't assume the window is definitely iconified afterward, because other entities (e.g. the user or window manager) could deiconify it again, or there may not be a window manager in which case iconification isn't possible, etc. But normally the window will end up iconified. Just don't write code that crashes if not.

It's permitted to call this function before showing a window, in which case the window will be iconified before it ever appears onscreen.

You can track iconification via the @SignalRef{widget,window-state-event} signal on GtkWidget.

@RMethod gtk-window-deiconify
@lisp
(gtk-window-deiconify window)
@end lisp

Asks to deiconify (i.e. unminimize) the specified window. Note that you shouldn't assume the window is definitely deiconified afterward, because other entities (e.g. the user or window manager) could iconify it again before your code which assumes deiconification gets to run.

You can track iconification via the @SignalRef{widget,window-state-event}.

@RMethod gtk-window-stick
@lisp
(gtk-window-stick window)
@end lisp
Asks to stick @var{window} (a @ref{gtk-window}), which means that it will appear on all user desktops. Note that you shouldn't assume the window is definitely stuck afterward, because other entities (e.g. the user or window manager) could unstick it again, and some window managers do not support sticking windows. But normally the window will end up stuck. Just don't write code that crashes if not.

It's permitted to call this function before showing a window.

You can track stickiness via the @SignalRef{widget,window-state-event} signal.

@RMethod gtk-window-unstick
@lisp
(gtk-window-unstick window)
@end lisp
Asks to unstick @var{window} (a @ref{gtk-window}), which means that it will appear on only one of the user's desktops. Note that you shouldn't assume the window is definitely unstuck afterward, because other entities (e.g. the user or window manager) could stick it again. But normally the window will end up stuck. Just don't write code that crashes if not.

You can track stickiness via the @SignalRef{widget,window-state-event} signal.

@RMethod gtk-window-maximize
@lisp
(gtk-window-maximize window)
@end lisp

Asks to maximize @var{window} (a @ref{gtk-window}), so that it becomes full-screen. Note that you shouldn't assume the window is definitely maximized afterward, because other entities (e.g. the user or window manager) could unmaximize it again, and not all window managers support maximization. But normally the window will end up maximized. Just don't write code that crashes if not.

It's permitted to call this function before showing a window, in which case the window will be maximized when it appears onscreen initially.

You can track maximization via the @SignalRef{widget,window-state-event} signal.

@RMethod gtk-window-unmaximize
@lisp
(gtk-window-unmaximize window)
@end lisp

Asks to unmaximize @var{window} (a @ref{gtk-window}). Note that you shouldn't assume the window is definitely unmaximized afterward, because other entities (e.g. the user or window manager) could maximize it again, and not all window managers honor requests to unmaximize. But normally the window will end up unmaximized. Just don't write code that crashes if not.

You can track maximization via the @SignalRef{widget,window-state-event} signal on GtkWidget.

@RMethod gtk-window-fullscreen
@lisp
(gtk-window-fullscreen window)
@end lisp

Asks to place @var{window} (a @ref{gtk-window}) in the fullscreen state. Note that you shouldn't assume the window is definitely full screen afterward, because other entities (e.g. the user or window manager) could unfullscreen it again, and not all window managers honor requests to fullscreen windows. But normally the window will end up fullscreen. Just don't write code that crashes if not.

You can track the fullscreen state via the @SignalRef{widget,window-state-event} signal.

@RMethod gtk-window-unfullscreen
@lisp
(gtk-window-unfullscreen window)
@end lisp

Asks to toggle off the fullscreen state for @var{window} (a @ref{gtk-window}). Note that you shouldn't assume the window is definitely not full screen afterward, because other entities (e.g. the user or window manager) could fullscreen it again, and not all window managers honor requests to unfullscreen windows. But normally the window will end up restored to its normal state. Just don't write code that crashes if not.

You can track the fullscreen state via the @SignalRef{widget,window-state-event} signal.

@RMethod gtk-window-begin-resize-drag
@lisp
(gtk-window-begin-resize-drag window edge button root-x root-y timestamp)
@end lisp

Starts resizing a @var{window} (a @ref{gtk-window}). This function is used if an application has window resizing controls. When GDK can support it, the resize will be done using the standard mechanism for the window manager or windowing system. Otherwise, GDK will try to emulate window resizing, potentially not all that well, depending on the windowing system.

@var{edge}: a @ref{window-edge}; position of the resize control

@var{button}: an integer; mouse button that initiated the drag

@var{root-x}: an integer; X position where the user clicked to initiate the drag, in root window coordinates

@var{root-y}: an integer; Y position where the user clicked to initiate the drag

@var{timestamp}: timestamp from the click event that initiated the drag

@RMethod gtk-window-begin-move-drag
@lisp
(gtk-window-begin-move-drag window button root-x root-y timestamp)
@end lisp

Starts moving a window. This function is used if an application has window movement grips. When GDK can support it, the window movement will be done using the standard mechanism for the window manager or windowing system. Otherwise, GDK will try to emulate window movement, potentially not all that well, depending on the windowing system.

@var{edge}: a @ref{window-edge}; position of the resize control

@var{button}: an integer; mouse button that initiated the drag

@var{root-x}: an integer; X position where the user clicked to initiate the drag, in root window coordinates

@var{root-y}: an integer; Y position where the user clicked to initiate the drag

@var{timestamp}: timestamp from the click event that initiated the drag

@RMethod gtk-window-set-frame-dimensions
@lisp
(gtk-window-set-frame-dimensions window left top right bottom)
@end lisp

(Note: this is a special-purpose function intended for the framebuffer port; see @SlotRef{gtk-window,has-frame}. It will have no effect on the window border drawn by the window manager, which is the normal case when using the X Window system.)

For windows with frames this function can be used to change the size of the frame border.

@var{window}: a @ref{gtk-window}

@var{left}, @var{top}, @var{right}, @var{bottom} - integers; sizes of left, top, right, bottom borders

@RFunction gtk-window-default-icon-list
@lisp
(gtk-window-default-icon-list) @result icons
(setf (gtk-window-default-icon-list) icons)
@end lisp

An icon list to be used as fallback for windows that haven't had @SlotRef{gtk-window,icon-list} set on them to set up a window-specific icon list. This function allows you to set up the icon for all windows in your app at once.

@var{icons}: a list of @ref{pixbuf}s.

@RFunction gtk-window-default-icon
@lisp
(setf (gtk-window-default-icon) icon)
@end lisp

Sets an @var{icon} (a @ref{pixbuf}) to be used as fallback for windows that haven't had @SlotRef{gtk-window,icon} set on them from a pixbuf.

@RFunction gtk-window-default-icon-name
@lisp
(setf (gtk-window-default-icon-name) name)
@end lisp

Sets an icon (a @code{string} - the name of the themed icon) to be used as fallback for windows.

@RMethod gtk-window-move
@lisp
(gtk-window-move window x y)
@end lisp

Asks the window manager to move @var{window} (a @ref{gtk-window}) to the given position (defined by integers @var{x}, @var{y}). Window managers are free to ignore this; most window managers ignore requests for initial window positions (instead using a user-defined placement algorithm) and honor requests after the window has already been shown.

Note: the position is the position of the gravity-determined reference point for the window. The gravity determines two things: first, the location of the reference point in root window coordinates; and second, which point on the window is positioned at the reference point.

By default the gravity is @EnumVRef{gravity,north-west}, so the reference point is simply the x, y supplied. The top-left corner of the window decorations (aka window frame or border) will be placed at x, y. Therefore, to position a window at the top left of the screen, you want to use the default gravity (which is @EnumVRef{gravity,north-west}) and move the window to 0,0.

To position a window at the bottom right corner of the screen, you would set @EnumVRef{gravity,south-east}, which means that the reference point is at x + the window width and y + the window height, and the bottom-right corner of the window border will be placed at that reference point. So, to place a window in the bottom right corner you would first set gravity to south east, then write: gtk_window_move (window, gdk_screen_width() - window_width, gdk_screen_height() - window_height) (note that this example does not take multi-head scenarios into account).

The Extended Window Manager Hints specification at http://www.freedesktop.org/Standards/wm-spec has a nice table of gravities in the "implementation notes" section.

@RMethod gtk-window-resize
@lisp
(gtk-window-resize window width height)
@end lisp

Resizes the @var{window} (a @ref{gtk-window}) to @var{width} pixels by @var{height} pixels as if the user had done so, obeying geometry constraints. The default geometry constraint is that windows may not be smaller than their size request (see @SlotRef{widget,width-request}, @SlotRef{widget,height-request}).

If @ref{gtk-window-resize} is called before showing a window for the first time, it overrides any default size set with @SlotRef{gtk-window,default-width}, @SlotRef{gtk-window,default-height}.

Windows may not be resized smaller than 1 by 1 pixels.

@node h-box
@section h-box
@Class h-box
Superclass: @ref{box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{statusbar} @ref{file-chooser-button}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node h-button-box
@section h-button-box
@Class h-button-box
Superclass: @ref{button-box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node h-paned
@section h-paned
@Class h-paned
Superclass: @ref{paned} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node h-ruler
@section h-ruler
@Class h-ruler
Superclass: @ref{ruler} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node h-s-v
@section h-s-v
@Class h-s-v
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@item @anchor{signal.h-s-v.changed}"changed". Signature: (instance @ref{h-s-v}) @result{} void. Options: run-first.
@item @anchor{signal.h-s-v.move}"move". Signature: (instance @ref{h-s-v}), (arg-1 @ref{direction-type}) @result{} void. Options: run-last, action.
@end itemize




@node h-scale
@section h-scale
@Class h-scale
Superclass: @ref{scale} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

The @ref{h-scale} widget is used to allow the user to select a value using a horizontal slider.

The position to show the current value, and the number of decimal places shown can be set using the parent @ref{scale} class's functions.

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node h-scrollbar
@section h-scrollbar
@Class h-scrollbar
Superclass: @ref{scrollbar} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node h-separator
@section h-separator
@Class h-separator
Superclass: @ref{separator} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node handle-box
@section handle-box
@Class handle-box
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.handle-box.child-detached}child-detached. Type: @code{boolean}. Accessor: @anchor{fn.handle-box-child-detached}@code{handle-box-child-detached}. Read-only.
@item @anchor{slot.handle-box.handle-position}handle-position. Type: @ref{position-type}. Accessor: @anchor{fn.handle-box-handle-position}@code{handle-box-handle-position}.
@item @anchor{slot.handle-box.shadow}shadow. Type: @ref{shadow-type}. Accessor: @anchor{fn.handle-box-shadow}@code{handle-box-shadow}.
@item @anchor{slot.handle-box.shadow-type}shadow-type. Type: @ref{shadow-type}. Accessor: @anchor{fn.handle-box-shadow-type}@code{handle-box-shadow-type}.
@item @anchor{slot.handle-box.snap-edge}snap-edge. Type: @ref{position-type}. Accessor: @anchor{fn.handle-box-snap-edge}@code{handle-box-snap-edge}.
@item @anchor{slot.handle-box.snap-edge-set}snap-edge-set. Type: @code{boolean}. Accessor: @anchor{fn.handle-box-snap-edge-set}@code{handle-box-snap-edge-set}.
@end itemize


Signals:
@itemize
@item @anchor{signal.handle-box.child-attached}"child-attached". Signature: (instance @ref{handle-box}), (arg-1 @ref{widget}) @result{} void. Options: run-first.
@item @anchor{signal.handle-box.child-detached}"child-detached". Signature: (instance @ref{handle-box}), (arg-1 @ref{widget}) @result{} void. Options: run-first.
@end itemize




@node icon-view
@section icon-view
@Class icon-view
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable} @ref{cell-layout}

Slots:
@itemize
@item @anchor{slot.icon-view.column-spacing}column-spacing. Type: @code{integer}. Accessor: @anchor{fn.icon-view-column-spacing}@code{icon-view-column-spacing}.
@item @anchor{slot.icon-view.columns}columns. Type: @code{integer}. Accessor: @anchor{fn.icon-view-columns}@code{icon-view-columns}.
@item @anchor{slot.icon-view.item-width}item-width. Type: @code{integer}. Accessor: @anchor{fn.icon-view-item-width}@code{icon-view-item-width}.
@item @anchor{slot.icon-view.margin}margin. Type: @code{integer}. Accessor: @anchor{fn.icon-view-margin}@code{icon-view-margin}.
@item @anchor{slot.icon-view.markup-column}markup-column. Type: @code{integer}. Accessor: @anchor{fn.icon-view-markup-column}@code{icon-view-markup-column}.
@item @anchor{slot.icon-view.model}model. Type: @ref{tree-model}. Accessor: @anchor{fn.icon-view-model}@code{icon-view-model}.
@item @anchor{slot.icon-view.orientation}orientation. Type: @ref{orientation}. Accessor: @anchor{fn.icon-view-orientation}@code{icon-view-orientation}.
@item @anchor{slot.icon-view.pixbuf-column}pixbuf-column. Type: @code{integer}. Accessor: @anchor{fn.icon-view-pixbuf-column}@code{icon-view-pixbuf-column}.
@item @anchor{slot.icon-view.reorderable}reorderable. Type: @code{boolean}. Accessor: @anchor{fn.icon-view-reorderable}@code{icon-view-reorderable}.
@item @anchor{slot.icon-view.row-spacing}row-spacing. Type: @code{integer}. Accessor: @anchor{fn.icon-view-row-spacing}@code{icon-view-row-spacing}.
@item @anchor{slot.icon-view.selection-mode}selection-mode. Type: @ref{selection-mode}. Accessor: @anchor{fn.icon-view-selection-mode}@code{icon-view-selection-mode}.
@item @anchor{slot.icon-view.spacing}spacing. Type: @code{integer}. Accessor: @anchor{fn.icon-view-spacing}@code{icon-view-spacing}.
@item @anchor{slot.icon-view.text-column}text-column. Type: @code{integer}. Accessor: @anchor{fn.icon-view-text-column}@code{icon-view-text-column}.
@item @anchor{slot.icon-view.tooltip-column}tooltip-column. Type: @code{integer}. Accessor: @anchor{fn.icon-view-tooltip-column}@code{icon-view-tooltip-column}.
@end itemize


Signals:
@itemize
@item @anchor{signal.icon-view.activate-cursor-item}"activate-cursor-item". Signature: (instance @ref{icon-view}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.icon-view.item-activated}"item-activated". Signature: (instance @ref{icon-view}), (arg-1 @ref{tree-path}) @result{} void. Options: run-last.
@item @anchor{signal.icon-view.move-cursor}"move-cursor". Signature: (instance @ref{icon-view}), (arg-1 @ref{movement-step}), (arg-2 @code{integer}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.icon-view.select-all}"select-all". Signature: (instance @ref{icon-view}) @result{} void. Options: run-last, action.
@item @anchor{signal.icon-view.select-cursor-item}"select-cursor-item". Signature: (instance @ref{icon-view}) @result{} void. Options: run-last, action.
@item @anchor{signal.icon-view.selection-changed}"selection-changed". Signature: (instance @ref{icon-view}) @result{} void. Options: run-first.
@item @anchor{signal.icon-view.set-scroll-adjustments}"set-scroll-adjustments". Signature: (instance @ref{icon-view}), (arg-1 @ref{adjustment}), (arg-2 @ref{adjustment}) @result{} void. Options: run-last.
@item @anchor{signal.icon-view.toggle-cursor-item}"toggle-cursor-item". Signature: (instance @ref{icon-view}) @result{} void. Options: run-last, action.
@item @anchor{signal.icon-view.unselect-all}"unselect-all". Signature: (instance @ref{icon-view}) @result{} void. Options: run-last, action.
@end itemize




@node image
@section image
@Class image
Superclass: @ref{misc} @ref{atk-implementor-iface} @ref{buildable}

The @ref{image} widget displays an image. Various kinds of object can be displayed as an image; most typically, you would load a @ref{pixbuf} ("pixel buffer") from a file, and then display that. There's an @SlotRef{image,file} slot (with @code{:file} initarg) that is used to load @ref{pixbuf} from file:
@lisp
(make-instance 'image :file "myfile.png")
@end lisp

If the file isn't loaded successfully, the image will contain a "broken image" icon similar to that used in many web browsers. If you want to handle errors in loading the file yourself, for example by displaying an error message, then load the image and set the @SlotRef{image,pixbuf}.

The image file may contain an animation, if so the @ref{image} will display an animation (@ref{pixbuf-animation}) instead of a static image.

@ref{image} is a subclass of @ref{misc}, which implies that you can align it (center, left, right) and add padding to it, using @ref{misc} slot.

@ref{image} is a "no window" widget (has no @ref{gdk-window} of its own), so by default does not receive events. If you want to receive events on the image, such as button clicks, place the image inside a @ref{event-box}, then connect to the event signals on the event box.

When handling events on the event box, keep in mind that coordinates in the image may be different from event box coordinates due to the alignment and padding settings on the image (see @ref{misc}). The simplest way to solve this is to set the alignment to 0.0 (left/top), and set the padding to zero. Then the origin of the image will be the same as the origin of the event box.

@c Sometimes an application will want to avoid depending on external data files, such as image files. GTK+ comes with a program to avoid this, called gdk-pixbuf-csource. This program allows you to convert an image into a C variable declaration, which can then be loaded into a GdkPixbuf using gdk_pixbuf_new_from_inline().

Slots:
@itemize
@item @anchor{slot.image.file}file. Type: @code{string}. Accessor: @anchor{fn.image-file}@code{image-file}.

Filename to load and display.

Default value: NIL
@item @anchor{slot.image.gicon}gicon. Type: @code{GIcon}. Accessor: @anchor{fn.image-gicon}@code{image-gicon}.

The GIcon displayed in the GtkImage. For themed icons, If the icon theme is changed, the image will be updated automatically.

TODO: GIcon is part of GIO library that is not yet supported by cl-gtk2
@item @anchor{slot.image.icon-name}icon-name. Type: @code{string}. Accessor: @anchor{fn.image-icon-name}@code{image-icon-name}.

The name of the icon in the icon theme. If the icon theme is changed, the image will be updated automatically.

Default value: NIL
@item @anchor{slot.image.icon-set}icon-set. Type: @code{GtkIconSet}. Accessor: @anchor{fn.image-icon-set}@code{image-icon-set}.

Icon set to display.
@item @anchor{slot.image.icon-size}icon-size. Type: @code{integer}. Accessor: @anchor{fn.image-icon-size}@code{image-icon-size}.

Symbolic size to use for stock icon, icon set or named icon.

Allowed values: >= 0

Default value: 4
@item @anchor{slot.image.image}image. Type: @ref{gdk-image}. Accessor: @anchor{fn.image-image}@code{image-image}.

A GdkImage to display.
@item @anchor{slot.image.mask}mask. Type: @ref{pixmap}. Accessor: @anchor{fn.image-mask}@code{image-mask}.

Mask bitmap to use with @ref{gdk-image} or @ref{pixmap}.
@item @anchor{slot.image.pixbuf}pixbuf. Type: @ref{pixbuf}. Accessor: @anchor{fn.image-pixbuf}@code{image-pixbuf}.

A @ref{pixbuf} to display.
@item @anchor{slot.image.pixbuf-animation}pixbuf-animation. Type: @ref{pixbuf-animation}. Accessor: @anchor{fn.image-pixbuf-animation}@code{image-pixbuf-animation}.

@ref{pixbuf-animation} to display.
@item @anchor{slot.image.pixel-size}pixel-size. Type: @code{integer}. Accessor: @anchor{fn.image-pixel-size}@code{image-pixel-size}.

This property can be used to specify a fixed size overriding the @SlotRef{image,icon-size} property for images of type @EnumVRef{image-type,icon-name}.

Default value: -1
@item @anchor{slot.image.pixmap}pixmap. Type: @ref{pixmap}. Accessor: @anchor{fn.image-pixmap}@code{image-pixmap}.

A @ref{pixmap} to display.
@item @anchor{slot.image.stock}stock. Type: @code{string}. Accessor: @anchor{fn.image-stock}@code{image-stock}.

Stock ID for a stock image to display.

Default value: NIL
@item @anchor{slot.image.storage-type}storage-type. Type: @ref{image-type}. Accessor: @anchor{fn.image-storage-type}@code{image-storage-type}. Read-only.

The representation being used for image data.

Default value: @EnumVRef{image-type,empty}
@end itemize


Signals:
@itemize
@end itemize




@node image-menu-item
@section image-menu-item
@Class image-menu-item
Superclass: @ref{menu-item} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.image-menu-item.accel-group}accel-group. Type: @ref{accel-group}. Accessor: @anchor{fn.image-menu-item-accel-group}@code{image-menu-item-accel-group}. Write-only.
@item @anchor{slot.image-menu-item.always-show-image}always-show-image. Type: @code{boolean}. Accessor: @anchor{fn.image-menu-item-always-show-image}@code{image-menu-item-always-show-image}.
@item @anchor{slot.image-menu-item.image}image. Type: @ref{widget}. Accessor: @anchor{fn.image-menu-item-image}@code{image-menu-item-image}.
@item @anchor{slot.image-menu-item.use-stock}use-stock. Type: @code{boolean}. Accessor: @anchor{fn.image-menu-item-use-stock}@code{image-menu-item-use-stock}.
@end itemize


Signals:
@itemize
@end itemize




@node input-dialog
@section input-dialog
@Class input-dialog
Superclass: @ref{dialog} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@item @anchor{signal.input-dialog.disable-device}"disable-device". Signature: (instance @ref{input-dialog}), (arg-1 @code{GdkDevice}) @result{} void. Options: run-last.
@item @anchor{signal.input-dialog.enable-device}"enable-device". Signature: (instance @ref{input-dialog}), (arg-1 @code{GdkDevice}) @result{} void. Options: run-last.
@end itemize




@node invisible
@section invisible
@Class invisible
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable}

The @ref{invisible} widget is used internally in GTK+, and is probably not very useful for application developers.

It is used for reliable pointer grabs and selection handling in the code for drag-and-drop.

Slots:
@itemize
@item @anchor{slot.invisible.screen}screen. Type: @ref{screen}. Accessor: @anchor{fn.invisible-screen}@code{invisible-screen}.

The @ref{screen} where this window will be displayed.
@end itemize


Signals:
@itemize
@end itemize




@node item
@section item
@Class item
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{menu-item}

Slots:
@itemize
@end itemize


Signals:
@itemize
@item @anchor{signal.item.deselect}"deselect". Signature: (instance @ref{item}) @result{} void. Options: run-first.
@item @anchor{signal.item.select}"select". Signature: (instance @ref{item}) @result{} void. Options: run-first.
@item @anchor{signal.item.toggle}"toggle". Signature: (instance @ref{item}) @result{} void. Options: run-first.
@end itemize




@node label
@section label
@Class label
Superclass: @ref{misc} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{accel-label}

The @ref{label} widget displays a small amount of text. As the name implies, most labels are used to label another widget such as a @ref{button}, or a @ref{menu-item}.

@chapheading Mnemonics

Labels may contain mnemonics. Mnemonics are underlined characters in the label, used for keyboard navigation. Mnemonics are created by providing a string with an underscore before the mnemonic character, such as "_File", to @SlotRef{label,label} and setting @SlotRef{label,use-underline} to True.

Mnemonics automatically activate any activatable widget the label is inside, such as a @ref{button}; if the label is not inside the mnemonic's target widget, you have to tell the label about the target by settings @SlotRef{label,mnemonic-widget}. Here's a simple example where the label is inside a button:

@chapheading Markup (styled text)

To make it easy to format text in a label (changing colors, fonts, etc.), label text can be provided in a simple markup format. Set @SlotRef{label,use-markup} to True if @SlotRef{label,label} contains markup. Here's how to create a label with a small font:
@lisp
(make-instance 'label :label "<small>Small text</small>" :use-markup t)
@end lisp
(See @uref{http://library.gnome.org/devel/pango/stable/PangoMarkupFormat.html,,complete documentation} of available tags in the Pango manual.)

The markup passed to @SlotRef{label,label} must be valid; for example, literal @code{</>/&} characters must be escaped as @code{&lt;}, @code{&gt;}, and @code{&amp;}. If you pass text obtained from the user, file, or a network, you'll want to escape it with g_markup_escape_text() or g_markup_printf_escaped(). (TODO: these functions are not supported yet in cl-gtk2)

Markup strings are just a convenient way to set the PangoAttrList on a label; @SlotRef{label,attributes} may be a simpler way to set attributes in some cases. Be careful though; PangoAttrList tends to cause internationalization problems, unless you're applying attributes to the entire string (i.e. unless you set the range of each attribute to [0, G_MAXINT)). The reason is that specifying the start_index and end_index for a PangoAttribute requires knowledge of the exact string being displayed, so translations will cause problems.

@chapheading Selectable labels

Labels can be made selectable with @SlotRef{label,selectable}. Selectable labels allow the user to copy the label contents to the clipboard. Only labels that contain useful-to-copy information - such as error messages - should be made selectable.

@chapheading Text layout

A label can contain any number of paragraphs, but will have performance problems if it contains more than a small number. Paragraphs are separated by newlines or other paragraph separators understood by Pango.

Labels can automatically wrap text if you call @SlotRef{label,line-wrap}.

@SlotRef{label,justify} sets how the lines in a label align with one another. If you want to set how the label as a whole aligns in its available space, see @SlotRef{misc,xalign} and @SlotRef{misc,yalign}.

Slots:
@itemize
@item @anchor{slot.label.angle}angle. Type: @code{double-float}. Accessor: @anchor{fn.label-angle}@code{label-angle}.

The angle that the baseline of the label makes with the horizontal, in degrees, measured counterclockwise. An angle of 90 reads from from bottom to top, an angle of 270, from top to bottom. Ignored if the label is selectable, wrapped, or ellipsized.

Allowed values: [0,360]

Default value: 0
@item @anchor{slot.label.attributes}attributes. Type: @code{PangoAttrList}. Accessor: @anchor{fn.label-attributes}@code{label-attributes}.

A list of style attributes to apply to the text of the label
@item @anchor{slot.label.cursor-position}cursor-position. Type: @code{integer}. Accessor: @anchor{fn.label-cursor-position}@code{label-cursor-position}. Read-only.

The current position of the insertion cursor in chars.

Allowed values: >= 0

Default value: 0
@item @anchor{slot.label.ellipsize}ellipsize. Type: @ref{pango-ellipsize-mode}. Accessor: @anchor{fn.label-ellipsize}@code{label-ellipsize}.

The preferred place to ellipsize the string, if the label does not have enough room to display the entire string.

Note that setting this property to a value other than @EnumVRef{pango-ellipsize-mode,none} has the side-effect that the label requests only enough space to display the ellipsis "...". In particular, this means that ellipsizing labels do not work well in notebook tabs, unless the tab's "tab-expand" property is set to True. Other ways to set a label's width are @SlotRef{widget,width-request} and @SlotRef{label,width-chars}.

Default value: @EnumVRef{pango-ellipsize-mode,none}
@item @anchor{slot.label.justify}justify. Type: @ref{justification}. Accessor: @anchor{fn.label-justify}@code{label-justify}.

The alignment of the lines in the text of the label relative to each other. This does NOT affect the alignment of the label within its allocation. See @SlotRef{misc,xalign} for that.

Default value: @EnumVRef{justification,left}
@item @anchor{slot.label.label}label. Type: @code{string}. Accessor: @anchor{fn.label-label}@code{label-label}.

The text of the label.

Default value: ""
@item @anchor{slot.label.layout}layout. Type: @ref{g-object}. Accessor: @anchor{fn.label-layout}@code{label-layout}. Read-only.

Gets the PangoLayout used to display the label. The layout is useful to e.g. convert text positions to pixel positions, in combination with @SlotRef{label,layout-offsets}.
@item @anchor{slot.label.layout-offsets}layout-offsets. Type: list of @code{integer}. Accessor: @anchor{fn.label-layout-offsets}@code{label-layout-offsets}. Read-only.

The coordinates where the label will draw the @code{PangoLayout} representing the text in the label; useful to convert mouse events into coordinates inside the @code{PangoLayout}, e.g. to take some action if some part of the label is clicked. Of course you will need to create a @ref{event-box} to receive the events, and pack the label inside it, since labels are a no-window widgets. Remember when using the @code{PangoLayout} functions you need to convert to and from pixels using PANGO_PIXELS or PANGO_SCALE.
@item @anchor{slot.label.line-wrap}line-wrap. Type: @code{boolean}. Accessor: @anchor{fn.label-line-wrap}@code{label-line-wrap}.

Whether lines in the label are automatically wrapped. True makes label break lines if text exceeds the widget's size. False lets the text get cut off by the edge of the widget if it exceeds the widget size.

Note that setting line wrapping to True does not make the label wrap at its parent container's width, because GTK+ widgets conceptually can't make their requisition depend on the parent container's size. For a label that wraps at a specific position, set the label's width using @SlotRef{widget,width-request}.
@item @anchor{slot.label.line-wrap-mode}line-wrap-mode. Type: @ref{pango-wrap-mode}. Accessor: @anchor{fn.label-line-wrap-mode}@code{label-line-wrap-mode}.

If line wrapping is on (see @SlotRef{label,line-wrap}) this controls how the line wrapping is done. The default is @EnumVRef{pango-wrap-mode,word} which means wrap on word boundaries.
@item @anchor{slot.label.max-width-chars}max-width-chars. Type: @code{integer}. Accessor: @anchor{fn.label-max-width-chars}@code{label-max-width-chars}.

The desired maximum width of the label, in characters. If this property is set to -1, the width will be calculated automatically, otherwise the label will request space for no more than the requested number of characters. If the @SlotRef{label,width-chars} property is set to a positive value, then the @SlotRef{label,max-width-chars} property is ignored.

Default value: -1
@item @anchor{slot.label.mnemonic-keyval}mnemonic-keyval. Type: @code{integer}. Accessor: @anchor{fn.label-mnemonic-keyval}@code{label-mnemonic-keyval}. Read-only.

The mnemonic accelerator key for this label.

Default value: 16777215
@item @anchor{slot.label.mnemonic-widget}mnemonic-widget. Type: @ref{widget}. Accessor: @anchor{fn.label-mnemonic-widget}@code{label-mnemonic-widget}.

The widget to be activated when the label's mnemonic key is pressed.
@item @anchor{slot.label.pattern}pattern. Type: @code{string}. Accessor: @anchor{fn.label-pattern}@code{label-pattern}. Write-only.

A string with _ characters in positions correspond to characters in the text to underline.

Default value: NIL
@item @anchor{slot.label.selectable}selectable. Type: @code{boolean}. Accessor: @anchor{fn.label-selectable}@code{label-selectable}.

Whether the label text can be selected with the mouse.

Default value: False
@item @anchor{slot.label.selection-bound}selection-bound. Type: @code{integer}. Accessor: @anchor{fn.label-selection-bound}@code{label-selection-bound}. Read-only.

The position of the opposite end of the selection from the cursor in chars.

Allowed values: >= 0

Default value: 0
@item @anchor{slot.label.selection-bounds}selection-bounds. Type: @code{(list integer integer)}. Accessor: @anchor{fn.label-selection-bounds}@code{label-selection-bounds}. Read-only.

Gets the selected range of characters in the label. Returns either NIL if there is no selection or list of two integers specifying character offsets of start and end of a selection
@item @anchor{slot.label.single-line-mode}single-line-mode. Type: @code{boolean}. Accessor: @anchor{fn.label-single-line-mode}@code{label-single-line-mode}.

Whether the label is in single line mode. In single line mode, the height of the label does not depend on the actual text, it is always set to ascent + descent of the font. This can be an advantage in situations where resizing the label because of text changes would be distracting, e.g. in a statusbar.

Default value: False
@item @anchor{slot.label.use-markup}use-markup. Type: @code{boolean}. Accessor: @anchor{fn.label-use-markup}@code{label-use-markup}.

The text of the label includes XML markup.

Default value: False
@item @anchor{slot.label.use-underline}use-underline. Type: @code{boolean}. Accessor: @anchor{fn.label-use-underline}@code{label-use-underline}.

If set, an underline in the text indicates the next character should be used for the mnemonic accelerator key.

Default value: False
@item @anchor{slot.label.width-chars}width-chars. Type: @code{integer}. Accessor: @anchor{fn.label-width-chars}@code{label-width-chars}.

he desired width of the label, in characters. If this property is set to -1, the width will be calculated automatically, otherwise the label will request either 3 characters or the property value, whichever is greater. If the @SlotRef{label,width-chars} property is set to a positive value, then the @SlotRef{label,max-width-chars} property is ignored.

Default value: -1
@item @anchor{slot.label.wrap}wrap. Type: @code{boolean}. Accessor: @anchor{fn.label-wrap}@code{label-wrap}.

If set, wrap lines if the text becomes too wide.

Default value: False
@item @anchor{slot.label.wrap-mode}wrap-mode. Type: @ref{pango-wrap-mode}. Accessor: @anchor{fn.label-wrap-mode}@code{label-wrap-mode}.

If line wrapping is on (see the @SlotRef{label,wrap} property) this controls how the line wrapping is done. The default is @EnumVRef{pango-wrap-mode,word}, which means wrap on word boundaries.
@end itemize


Signals:
@itemize
@item @anchor{signal.label.copy-clipboard}"copy-clipboard". Signature: (instance @ref{label}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted to copy the selection to the clipboard.

The default binding for this signal is Ctrl-c.
@item @anchor{signal.label.move-cursor}"move-cursor". Signature: (instance @ref{label}), (step @ref{movement-step}), (count @code{integer}), (extend-selection @code{boolean}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted when the user initiates a cursor movement. If the cursor is not visible in entry, this signal causes the viewport to be moved instead.

Applications should not connect to it, but may emit it with @ref{emit-signal} if they need to control the cursor programmatically.

The default bindings for this signal come in two variants, the variant with the Shift modifier extends the selection, the variant without the Shift modifer does not. There are too many key combinations to list them all here.

@itemize
@item Arrow keys move by individual characters/lines
@item Ctrl-arrow key combinations move by words/paragraphs
@item Home/End keys move to the ends of the buffer
@end itemize


@var{step}: the granularity of the move, as a GtkMovementStep

@var{count}: the number of step units to move

@var{extend-selection}: True if the move should extend the selection
@item @anchor{signal.label.populate-popup}"populate-popup". Signature: (instance @ref{label}), (menu @ref{menu}) @result{} void. Options: run-last.

This signal gets emitted before showing the context menu of the label. Note that only selectable labels have context menus.

If you need to add items to the context menu, connect to this signal and append your menuitems to the menu.
@end itemize




@node layout
@section layout
@Class layout
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.layout.bin-window}bin-window. Type: @ref{g-object}. Accessor: @anchor{fn.layout-bin-window}@code{layout-bin-window}. Read-only.
@item @anchor{slot.layout.hadjustment}hadjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.layout-hadjustment}@code{layout-hadjustment}.
@item @anchor{slot.layout.height}height. Type: @code{integer}. Accessor: @anchor{fn.layout-height}@code{layout-height}.
@item @anchor{slot.layout.vadjustment}vadjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.layout-vadjustment}@code{layout-vadjustment}.
@item @anchor{slot.layout.width}width. Type: @code{integer}. Accessor: @anchor{fn.layout-width}@code{layout-width}.
@end itemize


Signals:
@itemize
@item @anchor{signal.layout.set-scroll-adjustments}"set-scroll-adjustments". Signature: (instance @ref{layout}), (arg-1 @ref{adjustment}), (arg-2 @ref{adjustment}) @result{} void. Options: run-last, action.
@end itemize




@node link-button
@section link-button
@Class link-button
Superclass: @ref{button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

A @ref{link-button} is a @ref{button} with a hyperlink, similar to the one used by web browsers, which triggers an action when clicked. It is useful to show quick links to resources.

@ref{link-button} offers a global hook, which is called when the used clicks on it: see @ref{link-button-global-uri-hook}.

Slots:
@itemize
@item @anchor{slot.link-button.uri}uri. Type: @code{string}. Accessor: @anchor{fn.link-button-uri}@code{link-button-uri}.

The URI bound to this button.

Default value: NIL
@item @anchor{slot.link-button.visited}visited. Type: @code{boolean}. Accessor: @anchor{fn.link-button-visited}@code{link-button-visited}.

The 'visited' state of this button. A visited link is drawn in a different color.

Default value: False
@end itemize


Signals:
@itemize
@end itemize

@RFunction link-button-global-uri-hook
@lisp
(setf (link-button-gloval-uri-hook) function)
@end lisp

Sets function as the function that should be invoked every time a user clicks a @ref{link-button}. This function is called before every callback registered for the @SignalRef{button,clicked} signal.

If @var{function} is NIL, GTK+ defaults to calling gtk_show_uri() (default function that opens the default application for a URI).

@var{function} is a function of two arguments: a @ref{link-button} and a @code{string}. First argument is the button that was clicked and the second is the URI of the button.

@node menu
@section menu
@Class menu
Superclass: @ref{menu-shell} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{recent-chooser-menu}

Slots:
@itemize
@item @anchor{slot.menu.accel-group}accel-group. Type: @ref{accel-group}. Accessor: @anchor{fn.menu-accel-group}@code{menu-accel-group}.
@item @anchor{slot.menu.accel-path}accel-path. Type: @code{string}. Accessor: @anchor{fn.menu-accel-path}@code{menu-accel-path}.
@item @anchor{slot.menu.active}active. Type: @code{integer}. Accessor: @anchor{fn.menu-active}@code{menu-active}.
@item @anchor{slot.menu.attach-widget}attach-widget. Type: @ref{widget}. Accessor: @anchor{fn.menu-attach-widget}@code{menu-attach-widget}.
@item @anchor{slot.menu.monitor}monitor. Type: @code{integer}. Accessor: @anchor{fn.menu-monitor}@code{menu-monitor}.
@item @anchor{slot.menu.screen}screen. Type: @ref{g-object}. Accessor: @anchor{fn.menu-screen}@code{menu-screen}. Write-only.
@item @anchor{slot.menu.tearoff-state}tearoff-state. Type: @code{boolean}. Accessor: @anchor{fn.menu-tearoff-state}@code{menu-tearoff-state}.
@item @anchor{slot.menu.tearoff-title}tearoff-title. Type: @code{string}. Accessor: @anchor{fn.menu-tearoff-title}@code{menu-tearoff-title}.
@end itemize


Signals:
@itemize
@item @anchor{signal.menu.move-scroll}"move-scroll". Signature: (instance @ref{menu}), (arg-1 @ref{scroll-type}) @result{} void. Options: run-last, action.
@end itemize




@node menu-bar
@section menu-bar
@Class menu-bar
Superclass: @ref{menu-shell} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.menu-bar.child-pack-direction}child-pack-direction. Type: @ref{pack-direction}. Accessor: @anchor{fn.menu-bar-child-pack-direction}@code{menu-bar-child-pack-direction}.
@item @anchor{slot.menu-bar.pack-direction}pack-direction. Type: @ref{pack-direction}. Accessor: @anchor{fn.menu-bar-pack-direction}@code{menu-bar-pack-direction}.
@end itemize


Signals:
@itemize
@end itemize




@node menu-item
@section menu-item
@Class menu-item
Superclass: @ref{item} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Subclasses: @ref{tearoff-menu-item} @ref{separator-menu-item} @ref{image-menu-item} @ref{check-menu-item}

Slots:
@itemize
@item @anchor{slot.menu-item.accel-path}accel-path. Type: @code{string}. Accessor: @anchor{fn.menu-item-accel-path}@code{menu-item-accel-path}.
@item @anchor{slot.menu-item.label}label. Type: @code{string}. Accessor: @anchor{fn.menu-item-label}@code{menu-item-label}.
@item @anchor{slot.menu-item.right-justified}right-justified. Type: @code{boolean}. Accessor: @anchor{fn.menu-item-right-justified}@code{menu-item-right-justified}.
@item @anchor{slot.menu-item.submenu}submenu. Type: @ref{menu}. Accessor: @anchor{fn.menu-item-submenu}@code{menu-item-submenu}.
@item @anchor{slot.menu-item.use-underline}use-underline. Type: @code{boolean}. Accessor: @anchor{fn.menu-item-use-underline}@code{menu-item-use-underline}.
@end itemize


Signals:
@itemize
@item @anchor{signal.menu-item.activate}"activate". Signature: (instance @ref{menu-item}) @result{} void. Options: run-first, action.
@item @anchor{signal.menu-item.activate-item}"activate-item". Signature: (instance @ref{menu-item}) @result{} void. Options: run-first.
@item @anchor{signal.menu-item.toggle-size-allocate}"toggle-size-allocate". Signature: (instance @ref{menu-item}), (arg-1 @code{integer}) @result{} void. Options: run-first.
@item @anchor{signal.menu-item.toggle-size-request}"toggle-size-request". Signature: (instance @ref{menu-item}), (arg-1 gpointer) @result{} void. Options: run-first.
@end itemize




@node menu-shell
@section menu-shell
@Class menu-shell
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{menu-bar} @ref{menu}

Slots:
@itemize
@item @anchor{slot.menu-shell.take-focus}take-focus. Type: @code{boolean}. Accessor: @anchor{fn.menu-shell-take-focus}@code{menu-shell-take-focus}.
@end itemize


Signals:
@itemize
@item @anchor{signal.menu-shell.activate-current}"activate-current". Signature: (instance @ref{menu-shell}), (arg-1 @code{boolean}) @result{} void. Options: run-last, action.
@item @anchor{signal.menu-shell.cancel}"cancel". Signature: (instance @ref{menu-shell}) @result{} void. Options: run-last, action.
@item @anchor{signal.menu-shell.cycle-focus}"cycle-focus". Signature: (instance @ref{menu-shell}), (arg-1 @ref{direction-type}) @result{} void. Options: run-last, action.
@item @anchor{signal.menu-shell.deactivate}"deactivate". Signature: (instance @ref{menu-shell}) @result{} void. Options: run-first.
@item @anchor{signal.menu-shell.move-current}"move-current". Signature: (instance @ref{menu-shell}), (arg-1 @ref{menu-direction-type}) @result{} void. Options: run-last, action.
@item @anchor{signal.menu-shell.move-selected}"move-selected". Signature: (instance @ref{menu-shell}), (arg-1 @code{integer}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.menu-shell.selection-done}"selection-done". Signature: (instance @ref{menu-shell}) @result{} void. Options: run-first.
@end itemize




@node menu-tool-button
@section menu-tool-button
@Class menu-tool-button
Superclass: @ref{tool-button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.menu-tool-button.arrow-tooltip-markup}arrow-tooltip-markup. Type: @code{string}. Accessor: @anchor{fn.menu-tool-button-arrow-tooltip-markup}@code{menu-tool-button-arrow-tooltip-markup}. Write-only.
@item @anchor{slot.menu-tool-button.arrow-tooltip-text}arrow-tooltip-text. Type: @code{string}. Accessor: @anchor{fn.menu-tool-button-arrow-tooltip-text}@code{menu-tool-button-arrow-tooltip-text}. Write-only.
@item @anchor{slot.menu-tool-button.menu}menu. Type: @ref{menu}. Accessor: @anchor{fn.menu-tool-button-menu}@code{menu-tool-button-menu}.
@end itemize


Signals:
@itemize
@item @anchor{signal.menu-tool-button.show-menu}"show-menu". Signature: (instance @ref{menu-tool-button}) @result{} void. Options: run-first.
@end itemize




@node message-dialog
@section message-dialog
@Class message-dialog
Superclass: @ref{dialog} @ref{atk-implementor-iface} @ref{buildable}

@ref{message-dialog} presents a dialog with an image representing the
type of message (Error, Question, etc.) alongside some message
text. It's simply a convenience widget; you could construct the
equivalent of @ref{message-dialog} from @ref{dialog} without too much
effort, but @ref{message-dialog} saves typing.

The easiest way to do a modal message dialog is to use gtk_dialog_run(),
though you can also pass in the @FlagsVRef{dialog-flags,modal} flag,
@ref{dialog-run} automatically makes the dialog modal and waits for the
user to respond to it. @ref{dialog-run} returns when any dialog button
is clicked.

Slots:
@itemize
@item @anchor{slot.message-dialog.buttons}buttons. Type: @ref{buttons-type}. Accessor: @anchor{fn.message-dialog-buttons}@code{message-dialog-buttons}. Write-only.

The buttons shown in the message dialog.

Default value: @EnumVRef{buttons-type,none}
@item @anchor{slot.message-dialog.image}image. Type: @ref{widget}. Accessor: @anchor{fn.message-dialog-image}@code{message-dialog-image}.

The image for this dialog
@item @anchor{slot.message-dialog.message-type}message-type. Type: @ref{message-type}. Accessor: @anchor{fn.message-dialog-message-type}@code{message-dialog-message-type}.

The type of the message. The type is used to determine the image that is shown in the dialog, unless the image is explicitly set by the @SlotRef{message-dialog,image} property.

Default value: @EnumVRef{message-type,info}
@item @anchor{slot.message-dialog.secondary-text}secondary-text. Type: @code{string}. Accessor: @anchor{fn.message-dialog-secondary-text}@code{message-dialog-secondary-text}.

The secondary text of the message dialog.

Default value: NIL
@item @anchor{slot.message-dialog.secondary-use-markup}secondary-use-markup. Type: @code{boolean}. Accessor: @anchor{fn.message-dialog-secondary-use-markup}@code{message-dialog-secondary-use-markup}.

True if the secondary text of the dialog includes Pango markup. See pango_parse_markup().

Default value: False
@item @anchor{slot.message-dialog.text}text. Type: @code{string}. Accessor: @anchor{fn.message-dialog-text}@code{message-dialog-text}.

The primary text of the message dialog. If the dialog has a secondary text, this will appear as the title.

Default value: ""
@item @anchor{slot.message-dialog.use-markup}use-markup. Type: @code{boolean}. Accessor: @anchor{fn.message-dialog-use-markup}@code{message-dialog-use-markup}.

True if the primary text of the dialog includes Pango markup. See pango_parse_markup().

Default value: False
@end itemize


Signals:
@itemize
@end itemize


@node misc
@section misc
@Class misc
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{image} @ref{arrow} @ref{label}

Slots:
@itemize
@item @anchor{slot.misc.xalign}xalign. Type: @code{single-float}. Accessor: @anchor{fn.misc-xalign}@code{misc-xalign}.
@item @anchor{slot.misc.xpad}xpad. Type: @code{integer}. Accessor: @anchor{fn.misc-xpad}@code{misc-xpad}.
@item @anchor{slot.misc.yalign}yalign. Type: @code{single-float}. Accessor: @anchor{fn.misc-yalign}@code{misc-yalign}.
@item @anchor{slot.misc.ypad}ypad. Type: @code{integer}. Accessor: @anchor{fn.misc-ypad}@code{misc-ypad}.
@end itemize


Signals:
@itemize
@end itemize




@node notebook
@section notebook
@Class notebook
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.notebook.enable-popup}enable-popup. Type: @code{boolean}. Accessor: @anchor{fn.notebook-enable-popup}@code{notebook-enable-popup}.
@item @anchor{slot.notebook.group}group. Type: gpointer. Accessor: @anchor{fn.notebook-group}@code{notebook-group}.
@item @anchor{slot.notebook.group-id}group-id. Type: @code{integer}. Accessor: @anchor{fn.notebook-group-id}@code{notebook-group-id}.
@item @anchor{slot.notebook.homogeneous}homogeneous. Type: @code{boolean}. Accessor: @anchor{fn.notebook-homogeneous}@code{notebook-homogeneous}.
@item @anchor{slot.notebook.page}page. Type: @code{integer}. Accessor: @anchor{fn.notebook-page}@code{notebook-page}.
@item @anchor{slot.notebook.scrollable}scrollable. Type: @code{boolean}. Accessor: @anchor{fn.notebook-scrollable}@code{notebook-scrollable}.
@item @anchor{slot.notebook.show-border}show-border. Type: @code{boolean}. Accessor: @anchor{fn.notebook-show-border}@code{notebook-show-border}.
@item @anchor{slot.notebook.show-tabs}show-tabs. Type: @code{boolean}. Accessor: @anchor{fn.notebook-show-tabs}@code{notebook-show-tabs}.
@item @anchor{slot.notebook.tab-border}tab-border. Type: @code{integer}. Accessor: @anchor{fn.notebook-tab-border}@code{notebook-tab-border}. Write-only.
@item @anchor{slot.notebook.tab-hborder}tab-hborder. Type: @code{integer}. Accessor: @anchor{fn.notebook-tab-hborder}@code{notebook-tab-hborder}.
@item @anchor{slot.notebook.tab-pos}tab-pos. Type: @ref{position-type}. Accessor: @anchor{fn.notebook-tab-pos}@code{notebook-tab-pos}.
@item @anchor{slot.notebook.tab-vborder}tab-vborder. Type: @code{integer}. Accessor: @anchor{fn.notebook-tab-vborder}@code{notebook-tab-vborder}.
@end itemize


Signals:
@itemize
@item @anchor{signal.notebook.change-current-page}"change-current-page". Signature: (instance @ref{notebook}), (arg-1 @code{integer}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.notebook.create-window}"create-window". Signature: (instance @ref{notebook}), (arg-1 @ref{widget}), (arg-2 @code{integer}), (arg-3 @code{integer}) @result{} @ref{notebook}. Options: run-last.
@item @anchor{signal.notebook.focus-tab}"focus-tab". Signature: (instance @ref{notebook}), (arg-1 @ref{notebook-tab}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.notebook.move-focus-out}"move-focus-out". Signature: (instance @ref{notebook}), (arg-1 @ref{direction-type}) @result{} void. Options: run-last, action.
@item @anchor{signal.notebook.page-added}"page-added". Signature: (instance @ref{notebook}), (arg-1 @ref{widget}), (arg-2 @code{integer}) @result{} void. Options: run-last.
@item @anchor{signal.notebook.page-removed}"page-removed". Signature: (instance @ref{notebook}), (arg-1 @ref{widget}), (arg-2 @code{integer}) @result{} void. Options: run-last.
@item @anchor{signal.notebook.page-reordered}"page-reordered". Signature: (instance @ref{notebook}), (arg-1 @ref{widget}), (arg-2 @code{integer}) @result{} void. Options: run-last.
@item @anchor{signal.notebook.reorder-tab}"reorder-tab". Signature: (instance @ref{notebook}), (arg-1 @ref{direction-type}), (arg-2 @code{boolean}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.notebook.select-page}"select-page". Signature: (instance @ref{notebook}), (arg-1 @code{boolean}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.notebook.switch-page}"switch-page". Signature: (instance @ref{notebook}), (arg-1 gpointer), (arg-2 @code{integer}) @result{} void. Options: run-last.
@end itemize




@node page-setup-unix-dialog
@section page-setup-unix-dialog
@Class page-setup-unix-dialog
Superclass: @ref{dialog} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.page-setup-unix-dialog.page-setup}page-setup. Type: @ref{page-setup}. Accessor: @anchor{fn.page-setup-unix-dialog-page-setup}@code{page-setup-unix-dialog-page-setup}.
@item @anchor{slot.page-setup-unix-dialog.print-settings}print-settings. Type: @ref{print-settings}. Accessor: @anchor{fn.page-setup-unix-dialog-print-settings}@code{page-setup-unix-dialog-print-settings}.
@end itemize


Signals:
@itemize
@end itemize


@node paned
@section paned
@Class paned
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{v-paned} @ref{h-paned}

Slots:
@itemize
@item @anchor{slot.paned.max-position}max-position. Type: @code{integer}. Accessor: @anchor{fn.paned-max-position}@code{paned-max-position}. Read-only.
@item @anchor{slot.paned.min-position}min-position. Type: @code{integer}. Accessor: @anchor{fn.paned-min-position}@code{paned-min-position}. Read-only.
@item @anchor{slot.paned.position}position. Type: @code{integer}. Accessor: @anchor{fn.paned-position}@code{paned-position}.
@item @anchor{slot.paned.position-set}position-set. Type: @code{boolean}. Accessor: @anchor{fn.paned-position-set}@code{paned-position-set}.
@end itemize


Signals:
@itemize
@item @anchor{signal.paned.accept-position}"accept-position". Signature: (instance @ref{paned}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.paned.cancel-position}"cancel-position". Signature: (instance @ref{paned}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.paned.cycle-child-focus}"cycle-child-focus". Signature: (instance @ref{paned}), (arg-1 @code{boolean}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.paned.cycle-handle-focus}"cycle-handle-focus". Signature: (instance @ref{paned}), (arg-1 @code{boolean}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.paned.move-handle}"move-handle". Signature: (instance @ref{paned}), (arg-1 @ref{scroll-type}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.paned.toggle-handle-focus}"toggle-handle-focus". Signature: (instance @ref{paned}) @result{} @code{boolean}. Options: run-last, action.
@end itemize


@RMethod paned-pack-1
@lisp
paned-pack-1
@end lisp



@node plug
@section plug
@Class plug
Superclass: @ref{gtk-window} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.plug.embedded}embedded. Type: @code{boolean}. Accessor: @anchor{fn.plug-embedded}@code{plug-embedded}. Read-only.
@item @anchor{slot.plug.socket-window}socket-window. Type: @ref{gdk-window}. Accessor: @anchor{fn.plug-socket-window}@code{plug-socket-window}. Read-only.
@end itemize


Signals:
@itemize
@item @anchor{signal.plug.embedded}"embedded". Signature: (instance @ref{plug}) @result{} void. Options: run-last.
@end itemize




@node print-unix-dialog
@section print-unix-dialog
@Class print-unix-dialog
Superclass: @ref{dialog} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.print-unix-dialog.current-page}current-page. Type: @code{integer}. Accessor: @anchor{fn.print-unix-dialog-current-page}@code{print-unix-dialog-current-page}.
@item @anchor{slot.print-unix-dialog.page-setup}page-setup. Type: @ref{page-setup}. Accessor: @anchor{fn.print-unix-dialog-page-setup}@code{print-unix-dialog-page-setup}.
@item @anchor{slot.print-unix-dialog.print-settings}print-settings. Type: @ref{print-settings}. Accessor: @anchor{fn.print-unix-dialog-print-settings}@code{print-unix-dialog-print-settings}.
@item @anchor{slot.print-unix-dialog.selected-printer}selected-printer. Type: @code{GtkPrinter}. Accessor: @anchor{fn.print-unix-dialog-selected-printer}@code{print-unix-dialog-selected-printer}. Read-only.
@end itemize


Signals:
@itemize
@end itemize


@node progress
@section progress
@Class progress
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{progress-bar}

Slots:
@itemize
@item @anchor{slot.progress.activity-mode}activity-mode. Type: @code{boolean}. Accessor: @anchor{fn.progress-activity-mode}@code{progress-activity-mode}.
@item @anchor{slot.progress.show-text}show-text. Type: @code{boolean}. Accessor: @anchor{fn.progress-show-text}@code{progress-show-text}.
@item @anchor{slot.progress.text-xalign}text-xalign. Type: @code{single-float}. Accessor: @anchor{fn.progress-text-xalign}@code{progress-text-xalign}.
@item @anchor{slot.progress.text-yalign}text-yalign. Type: @code{single-float}. Accessor: @anchor{fn.progress-text-yalign}@code{progress-text-yalign}.
@end itemize


Signals:
@itemize
@end itemize




@node progress-bar
@section progress-bar
@Class progress-bar
Superclass: @ref{progress} @ref{atk-implementor-iface} @ref{buildable}

The @ref{progress-bar} is typically used to display the progress of a long running operation. It provides a visual clue that processing is underway. The @ref{progress-bar} can be used in two different modes: percentage mode and activity  mode.

When an application can determine how much work needs to take place (e.g. read a fixed number of bytes from a file) and can monitor its progress, it can use the @ref{progress-bar} in percentage mode and the user sees a growing bar indicating the percentage of the work that has been completed. In this mode, the application is required to set @SlotRef{progress-bar,fraction} periodically to update the progress bar.

When an application has no accurate way of knowing the amount of work to do, it can use the @ref{progress-bar} in activity mode, which shows activity by a block moving back and forth within the progress area. In this mode, the application is required to call @ref{progress-bar-pulse} perodically to update the progress bar.

There is quite a bit of flexibility provided to control the appearance of the @ref{progress-bar}. Functions are provided to control the orientation of the bar, optional text can be displayed along with the bar, and the step size used in activity mode can be set.

Slots:
@itemize
@item @anchor{slot.progress-bar.activity-blocks}activity-blocks. Type: @code{integer}. Accessor: @anchor{fn.progress-bar-activity-blocks}@code{progress-bar-activity-blocks}.

The number of blocks which can fit in the progress bar area in activity mode (Deprecated).

Allowed values: >= 2

Default value: 5
@item @anchor{slot.progress-bar.activity-step}activity-step. Type: @code{integer}. Accessor: @anchor{fn.progress-bar-activity-step}@code{progress-bar-activity-step}.

The increment used for each iteration in activity mode (Deprecated).

Default value: 3
@item @anchor{slot.progress-bar.adjustment}adjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.progress-bar-adjustment}@code{progress-bar-adjustment}.

The @ref{adjustment} connected to the progress bar (Deprecated
@item @anchor{slot.progress-bar.bar-style}bar-style. Type: @ref{progress-bar-style}. Accessor: @anchor{fn.progress-bar-bar-style}@code{progress-bar-bar-style}.

Specifies the visual style of the bar in percentage mode (Deprecated).

Default value: @EnumVRef{progress-bar-style,continuous}
@item @anchor{slot.progress-bar.discrete-blocks}discrete-blocks. Type: @code{integer}. Accessor: @anchor{fn.progress-bar-discrete-blocks}@code{progress-bar-discrete-blocks}.

The number of discrete blocks in a progress bar (when shown in the discrete style).

Allowed values: >= 2

Default value: 10
@item @anchor{slot.progress-bar.ellipsize}ellipsize. Type: @ref{pango-ellipsize-mode}. Accessor: @anchor{fn.progress-bar-ellipsize}@code{progress-bar-ellipsize}.

The preferred place to ellipsize the string, if the progressbar does not have enough room to display the entire string.

Note that setting this property to a value other than @EnumVRef{pango-ellipsize-mode,none} has the side-effect that the progressbar requests only enough space to display the ellipsis "...". Another means to set a progressbar's width is @SlotRef{widget,width-request}.

Default value: @EnumVRef{pango-ellipsize-mode,none}
@item @anchor{slot.progress-bar.fraction}fraction. Type: @code{double-float}. Accessor: @anchor{fn.progress-bar-fraction}@code{progress-bar-fraction}.

The fraction of total work that has been completed.

Allowed values: [0,1]

Default value: 0
@item @anchor{slot.progress-bar.orientation}orientation. Type: @ref{progress-bar-orientation}. Accessor: @anchor{fn.progress-bar-orientation}@code{progress-bar-orientation}.

Orientation and growth direction of the progress bar.

Default value: @EnumVRef{progress-bar-orientation,left-to-right}
@item @anchor{slot.progress-bar.pulse-step}pulse-step. Type: @code{double-float}. Accessor: @anchor{fn.progress-bar-pulse-step}@code{progress-bar-pulse-step}.

The fraction of total progress to move the bouncing block when pulsed.

Allowed values: [0,1]

Default value: 0.1
@item @anchor{slot.progress-bar.text}text. Type: @code{string}. Accessor: @anchor{fn.progress-bar-text}@code{progress-bar-text}.

Text to be displayed in the progress bar.

Default value: NIL
@end itemize


Signals:
@itemize
@end itemize

@RMethod progress-bar-pulse
@lisp
(progress-bar-pulse progress-bar)
@end lisp

Indicates that some progress is made, but you don't know how much. Causes the progress bar to enter "activity mode," where a block bounces back and forth. Each call to @ref{progress-bar-pulse} causes the block to move by a little bit (the amount of movement per pulse is determined by @SlotRef{progress-bar,pulse-step}).

@node radio-button
@section radio-button
@Class radio-button
Superclass: @ref{check-button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

A single radio button performs the same basic function as a @ref{check-button}, as its position in the object hierarchy reflects. It is only when multiple radio buttons are grouped together that they become a different user interface component in their own right.

Every radio button is a member of some group of radio buttons. When one is selected, all other radio buttons in the same group are deselected. A @ref{radio-button} is one way of giving the user a choice from many options.

To group radio buttons into one group, set @SlotRef{radio-button,group} to one of the radio buttons of the group.

Slots:
@itemize
@item @anchor{slot.radio-button.group}group. Type: @ref{radio-button}. Accessor: @anchor{fn.radio-button-group}@code{radio-button-group}. Write-only.

A button of the radio button group that this radio button belongs to
@end itemize


Signals:
@itemize
@item @anchor{signal.radio-button.group-changed}"group-changed". Signature: (instance @ref{radio-button}) @result{} void. Options: run-first.

Emitted when the group of radio buttons that a radio button belongs to changes. This is emitted when a radio button switches from being alone to being part of a group of 2 or more buttons, or vice-versa, and when a button is moved from one group of 2 or more buttons to a different one, but not when the composition of the group that a button belongs to changes.
@end itemize




@node radio-menu-item
@section radio-menu-item
@Class radio-menu-item
Superclass: @ref{check-menu-item} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.radio-menu-item.group}group. Type: @ref{radio-menu-item}. Accessor: @anchor{fn.radio-menu-item-group}@code{radio-menu-item-group}. Write-only.
@end itemize


Signals:
@itemize
@item @anchor{signal.radio-menu-item.group-changed}"group-changed". Signature: (instance @ref{radio-menu-item}) @result{} void. Options: run-first.
@end itemize




@node radio-tool-button
@section radio-tool-button
@Class radio-tool-button
Superclass: @ref{toggle-tool-button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.radio-tool-button.group}group. Type: @ref{radio-tool-button}. Accessor: @anchor{fn.radio-tool-button-group}@code{radio-tool-button-group}. Write-only.
@end itemize


Signals:
@itemize
@end itemize




@node range
@section range
@Class range
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{scrollbar} @ref{scale}

Slots:
@itemize
@item @anchor{slot.range.adjustment}adjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.range-adjustment}@code{range-adjustment}.
@item @anchor{slot.range.fill-level}fill-level. Type: @code{double-float}. Accessor: @anchor{fn.range-fill-level}@code{range-fill-level}.
@item @anchor{slot.range.inverted}inverted. Type: @code{boolean}. Accessor: @anchor{fn.range-inverted}@code{range-inverted}.
@item @anchor{slot.range.lower-stepper-sensitivity}lower-stepper-sensitivity. Type: @ref{sensitivity-type}. Accessor: @anchor{fn.range-lower-stepper-sensitivity}@code{range-lower-stepper-sensitivity}.
@item @anchor{slot.range.restrict-to-fill-level}restrict-to-fill-level. Type: @code{boolean}. Accessor: @anchor{fn.range-restrict-to-fill-level}@code{range-restrict-to-fill-level}.
@item @anchor{slot.range.show-fill-level}show-fill-level. Type: @code{boolean}. Accessor: @anchor{fn.range-show-fill-level}@code{range-show-fill-level}.
@item @anchor{slot.range.update-policy}update-policy. Type: @ref{update-type}. Accessor: @anchor{fn.range-update-policy}@code{range-update-policy}.
@item @anchor{slot.range.upper-stepper-sensitivity}upper-stepper-sensitivity. Type: @ref{sensitivity-type}. Accessor: @anchor{fn.range-upper-stepper-sensitivity}@code{range-upper-stepper-sensitivity}.
@end itemize


Signals:
@itemize
@item @anchor{signal.range.adjust-bounds}"adjust-bounds". Signature: (instance @ref{range}), (arg-1 @code{double-float}) @result{} void. Options: run-last.
@item @anchor{signal.range.change-value}"change-value". Signature: (instance @ref{range}), (arg-1 @ref{scroll-type}), (arg-2 @code{double-float}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.range.move-slider}"move-slider". Signature: (instance @ref{range}), (arg-1 @ref{scroll-type}) @result{} void. Options: run-last, action.
@item @anchor{signal.range.value-changed}"value-changed". Signature: (instance @ref{range}) @result{} void. Options: run-last.
@end itemize




@node recent-chooser-dialog
@section recent-chooser-dialog
@Class recent-chooser-dialog
Superclass: @ref{dialog} @ref{atk-implementor-iface} @ref{buildable} @ref{recent-chooser}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node recent-chooser-menu
@section recent-chooser-menu
@Class recent-chooser-menu
Superclass: @ref{menu} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable} @ref{recent-chooser}

Slots:
@itemize
@item @anchor{slot.recent-chooser-menu.show-numbers}show-numbers. Type: @code{boolean}. Accessor: @anchor{fn.recent-chooser-menu-show-numbers}@code{recent-chooser-menu-show-numbers}.
@end itemize


Signals:
@itemize
@end itemize




@node recent-chooser-widget
@section recent-chooser-widget
@Class recent-chooser-widget
Superclass: @ref{v-box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable} @ref{recent-chooser}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node ruler
@section ruler
@Class ruler
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{v-ruler} @ref{h-ruler}

Slots:
@itemize
@item @anchor{slot.ruler.lower}lower. Type: @code{double-float}. Accessor: @anchor{fn.ruler-lower}@code{ruler-lower}.
@item @anchor{slot.ruler.max-size}max-size. Type: @code{double-float}. Accessor: @anchor{fn.ruler-max-size}@code{ruler-max-size}.
@item @anchor{slot.ruler.metric}metric. Type: @ref{metric-type}. Accessor: @anchor{fn.ruler-metric}@code{ruler-metric}.
@item @anchor{slot.ruler.position}position. Type: @code{double-float}. Accessor: @anchor{fn.ruler-position}@code{ruler-position}.
@item @anchor{slot.ruler.upper}upper. Type: @code{double-float}. Accessor: @anchor{fn.ruler-upper}@code{ruler-upper}.
@end itemize


Signals:
@itemize
@end itemize




@node scale
@section scale
@Class scale
Superclass: @ref{range} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{v-scale} @ref{h-scale}

Slots:
@itemize
@item @anchor{slot.scale.digits}digits. Type: @code{integer}. Accessor: @anchor{fn.scale-digits}@code{scale-digits}.
@item @anchor{slot.scale.draw-value}draw-value. Type: @code{boolean}. Accessor: @anchor{fn.scale-draw-value}@code{scale-draw-value}.
@item @anchor{slot.scale.value-pos}value-pos. Type: @ref{position-type}. Accessor: @anchor{fn.scale-value-pos}@code{scale-value-pos}.
@end itemize


Signals:
@itemize
@item @anchor{signal.scale.format-value}"format-value". Signature: (instance @ref{scale}), (arg-1 @code{double-float}) @result{} @code{string}. Options: run-last.
@end itemize




@node scale-button
@section scale-button
@Class scale-button
Superclass: @ref{button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable} @ref{orientable}

Subclasses: @ref{volume-button}

@ref{scale-button} provides a button which pops up a scale widget. This kind of widget is commonly used for volume controls in multimedia applications, and GTK+ provides a @ref{volume-button} subclass that is tailored for this use case.

Slots:
@itemize
@item @anchor{slot.scale-button.adjustment}adjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.scale-button-adjustment}@code{scale-button-adjustment}.

The @ref{adjustment} that contains the current value of this scale button object.
@item @anchor{slot.scale-button.icons}icons. Type: list of @code{string}. Accessor: @anchor{fn.scale-button-icons}@code{scale-button-icons}.

The names of the icons to be used by the scale button. The first item in the list will be used in the button when the current value is the lowest value, the second item for the highest value. All the subsequent icons will be used for all the other values, spread evenly over the range of values.

If there's only one icon name in the icons array, it will be used for all the values. If only two icon names are in the icons array, the first one will be used for the bottom 50% of the scale, and the second one for the top 50%.

It is recommended to use at least 3 icons so that the @ref{scale-button} reflects the current value of the scale better for the users.
@item @anchor{slot.scale-button.size}size. Type: @ref{icon-size}. Accessor: @anchor{fn.scale-button-size}@code{scale-button-size}.

The icon size.

Default value: @EnumVRef{icon-size,small-toolbar}
@item @anchor{slot.scale-button.value}value. Type: @code{double-float}. Accessor: @anchor{fn.scale-button-value}@code{scale-button-value}.

The value of the scale.

Default value: 0
@end itemize


Signals:
@itemize
@item @anchor{signal.scale-button.popdown}"popdown". Signature: (instance @ref{scale-button}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted to popdown the scale widget.

The default binding for this signal is Escape.
@item @anchor{signal.scale-button.popup}"popup". Signature: (instance @ref{scale-button}) @result{} void. Options: run-last, action.

This signal is a keybinding signal which gets emitted to popup the scale widget.

The default bindings for this signal are Space, Enter and Return.
@item @anchor{signal.scale-button.value-changed}"value-changed". Signature: (instance @ref{scale-button}), (arg-1 @code{double-float}) @result{} void. Options: run-last.

This signal is emitted when the value field has changed.
@end itemize




@node scrollbar
@section scrollbar
@Class scrollbar
Superclass: @ref{range} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{v-scrollbar} @ref{h-scrollbar}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node scrolled-window
@section scrolled-window
@Class scrolled-window
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.scrolled-window.hadjustment}hadjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.scrolled-window-hadjustment}@code{scrolled-window-hadjustment}.
@item @anchor{slot.scrolled-window.hscrollbar-policy}hscrollbar-policy. Type: @ref{policy-type}. Accessor: @anchor{fn.scrolled-window-hscrollbar-policy}@code{scrolled-window-hscrollbar-policy}.
@item @anchor{slot.scrolled-window.shadow-type}shadow-type. Type: @ref{shadow-type}. Accessor: @anchor{fn.scrolled-window-shadow-type}@code{scrolled-window-shadow-type}.
@item @anchor{slot.scrolled-window.vadjustment}vadjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.scrolled-window-vadjustment}@code{scrolled-window-vadjustment}.
@item @anchor{slot.scrolled-window.vscrollbar-policy}vscrollbar-policy. Type: @ref{policy-type}. Accessor: @anchor{fn.scrolled-window-vscrollbar-policy}@code{scrolled-window-vscrollbar-policy}.
@item @anchor{slot.scrolled-window.window-placement}window-placement. Type: @ref{corner-type}. Accessor: @anchor{fn.scrolled-window-window-placement}@code{scrolled-window-window-placement}.
@item @anchor{slot.scrolled-window.window-placement-set}window-placement-set. Type: @code{boolean}. Accessor: @anchor{fn.scrolled-window-window-placement-set}@code{scrolled-window-window-placement-set}.
@end itemize


Signals:
@itemize
@item @anchor{signal.scrolled-window.move-focus-out}"move-focus-out". Signature: (instance @ref{scrolled-window}), (arg-1 @ref{direction-type}) @result{} void. Options: run-last, action.
@item @anchor{signal.scrolled-window.scroll-child}"scroll-child". Signature: (instance @ref{scrolled-window}), (arg-1 @ref{scroll-type}), (arg-2 @code{boolean}) @result{} @code{boolean}. Options: run-last, action.
@end itemize




@node separator
@section separator
@Class separator
Superclass: @ref{widget} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{v-separator} @ref{h-separator}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node separator-menu-item
@section separator-menu-item
@Class separator-menu-item
Superclass: @ref{menu-item} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node separator-tool-item
@section separator-tool-item
@Class separator-tool-item
Superclass: @ref{tool-item} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.separator-tool-item.draw}draw. Type: @code{boolean}. Accessor: @anchor{fn.separator-tool-item-draw}@code{separator-tool-item-draw}.
@end itemize


Signals:
@itemize
@end itemize




@node socket
@section socket
@Class socket
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@item @anchor{signal.socket.plug-added}"plug-added". Signature: (instance @ref{socket}) @result{} void. Options: run-last.
@item @anchor{signal.socket.plug-removed}"plug-removed". Signature: (instance @ref{socket}) @result{} @code{boolean}. Options: run-last.
@end itemize




@node spin-button
@section spin-button
@Class spin-button
Superclass: @ref{entry} @ref{atk-implementor-iface} @ref{buildable} @ref{cell-editable} @ref{editable}

Slots:
@itemize
@item @anchor{slot.spin-button.adjustment}adjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.spin-button-adjustment}@code{spin-button-adjustment}.
@item @anchor{slot.spin-button.climb-rate}climb-rate. Type: @code{double-float}. Accessor: @anchor{fn.spin-button-climb-rate}@code{spin-button-climb-rate}.
@item @anchor{slot.spin-button.digits}digits. Type: @code{integer}. Accessor: @anchor{fn.spin-button-digits}@code{spin-button-digits}.
@item @anchor{slot.spin-button.numeric}numeric. Type: @code{boolean}. Accessor: @anchor{fn.spin-button-numeric}@code{spin-button-numeric}.
@item @anchor{slot.spin-button.snap-to-ticks}snap-to-ticks. Type: @code{boolean}. Accessor: @anchor{fn.spin-button-snap-to-ticks}@code{spin-button-snap-to-ticks}.
@item @anchor{slot.spin-button.update-policy}update-policy. Type: @ref{spin-button-update-policy}. Accessor: @anchor{fn.spin-button-update-policy}@code{spin-button-update-policy}.
@item @anchor{slot.spin-button.value}value. Type: @code{double-float}. Accessor: @anchor{fn.spin-button-value}@code{spin-button-value}.
@item @anchor{slot.spin-button.wrap}wrap. Type: @code{boolean}. Accessor: @anchor{fn.spin-button-wrap}@code{spin-button-wrap}.
@end itemize


Signals:
@itemize
@item @anchor{signal.spin-button.change-value}"change-value". Signature: (instance @ref{spin-button}), (arg-1 @ref{scroll-type}) @result{} void. Options: run-last, action.
@item @anchor{signal.spin-button.input}"input". Signature: (instance @ref{spin-button}), (arg-1 gpointer) @result{} @code{integer}. Options: run-last.
@item @anchor{signal.spin-button.output}"output". Signature: (instance @ref{spin-button}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.spin-button.value-changed}"value-changed". Signature: (instance @ref{spin-button}) @result{} void. Options: run-last.
@item @anchor{signal.spin-button.wrapped}"wrapped". Signature: (instance @ref{spin-button}) @result{} void. Options: run-last.
@end itemize




@node statusbar
@section statusbar
@Class statusbar
Superclass: @ref{h-box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

A @ref{statusbar} is usually placed along the bottom of an application's main @ref{gtk-window}. It may provide a regular commentary of the application's status (as is usually the case in a web browser, for example), or may be used to simply output a message when the status changes, (when an upload is complete in an FTP client, for example). It may also have a resize grip (a triangular area in the lower right corner) which can be clicked on to resize the window containing the statusbar.

Status bars in GTK+ maintain a stack of messages. The message at the top of the each bar's stack is the one that will currently be displayed.

Any messages added to a statusbar's stack must specify a context id that is used to uniquely identify the source of a message. Context ids may be specified by context descriptions (as string) or by numeric identifiers obtained by @ref{statusbar-context-id}. Note that messages are stored in a stack, and when choosing which message to display, the stack structure is adhered to, regardless of the context description of a message.

One could say that a statusbar maintains one stack of messages for display purposes, but allows multiple message producers to maintain sub-stacks of the messages they produced (via context descriptions).

Messages are added to the bar's stack with @ref{statusbar-push}.

The message at the top of the stack can be removed using @ref{statusbar-pop}. A message can be removed from anywhere in the stack if its @var{message-id} was recorded at the time it was added. This is done using @ref{statusbar-remove}.

Slots:
@itemize
@item @anchor{slot.statusbar.has-resize-grip}has-resize-grip. Type: @code{boolean}. Accessor: @anchor{fn.statusbar-has-resize-grip}@code{statusbar-has-resize-grip}.

Whether the statusbar has a grip for resizing the toplevel window.

Default value: True
@end itemize


Signals:
@itemize
@item @anchor{signal.statusbar.text-popped}"text-popped". Signature: (instance @ref{statusbar}), (context-id @code{integer}), (text @code{string}) @result{} void. Options: run-last.

Is emitted whenever a new message is popped off a statusbar's stack.

@var{context-id} is a numeric identifier of a context.
@item @anchor{signal.statusbar.text-pushed}"text-pushed". Signature: (instance @ref{statusbar}), (context-id @code{integer}), (text @code{string}) @result{} void. Options: run-last.

Is emitted whenever a new message gets pushed onto a statusbar's stack.

@var{context-id} is a numeric identifier of a context.
@end itemize

@RMethod statusbar-context-id
@lisp
(statusbar-context-id statusbar context-description) @result{} context-id
@end lisp

Returns a context identifier, given a description of the actual context. Note that the description is not shown in the UI.

@var{context-description} is a string - textual description of what context the new message is being used in

@RMethod statusbar-push
@lisp
(statusbar-push statusbar context text) @result{} message-id
@end lisp

Pushes a new message onto a statusbar's stack.

@var{context}: a string (context description) or a number obtained by @ref{statusbar-context-id}

@var{text}: the message to add to the statusbar

@var{message-id}: a message id that can be used with @ref{statusbar-remove}.

@RMethod statusbar-pop
@lisp
(statusbar-pop statusbar context)
@end lisp

Removes the first message in the @ref{statusbar}'s stack with the given context.

Note that this may not change the displayed message, if the message at the top of the stack has a different context.

@var{context}: a string (context description) or a number obtained by @ref{statusbar-context-id}

@RMethod statusbar-remove
@lisp
(statusbar-remove statusbar context message-id)
@end lisp

Forces the removal of a message from a statusbar's stack. The exact @var{context} and @var{message-id} must be specified.

@var{context}: a string (context description) or a number obtained by @ref{statusbar-context-id}

@var{message-id}: a message identifier returned by @ref{statusbar-push}

@node table
@section table
@Class table
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.table.column-spacing}column-spacing. Type: @code{integer}. Accessor: @anchor{fn.table-column-spacing}@code{table-column-spacing}.
@item @anchor{slot.table.homogeneous}homogeneous. Type: @code{boolean}. Accessor: @anchor{fn.table-homogeneous}@code{table-homogeneous}.
@item @anchor{slot.table.n-columns}n-columns. Type: @code{integer}. Accessor: @anchor{fn.table-n-columns}@code{table-n-columns}.
@item @anchor{slot.table.n-rows}n-rows. Type: @code{integer}. Accessor: @anchor{fn.table-n-rows}@code{table-n-rows}.
@item @anchor{slot.table.row-spacing}row-spacing. Type: @code{integer}. Accessor: @anchor{fn.table-row-spacing}@code{table-row-spacing}.
@end itemize


Signals:
@itemize
@end itemize


@RMethod table-attach
@lisp
table-attach
@end lisp



@node tearoff-menu-item
@section tearoff-menu-item
@Class tearoff-menu-item
Superclass: @ref{menu-item} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node text-view
@section text-view
@Class text-view
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.text-view.accepts-tab}accepts-tab. Type: @code{boolean}. Accessor: @anchor{fn.text-view-accepts-tab}@code{text-view-accepts-tab}.
@item @anchor{slot.text-view.buffer}buffer. Type: @ref{text-buffer}. Accessor: @anchor{fn.text-view-buffer}@code{text-view-buffer}.
@item @anchor{slot.text-view.cursor-visible}cursor-visible. Type: @code{boolean}. Accessor: @anchor{fn.text-view-cursor-visible}@code{text-view-cursor-visible}.
@item @anchor{slot.text-view.editable}editable. Type: @code{boolean}. Accessor: @anchor{fn.text-view-editable}@code{text-view-editable}.
@item @anchor{slot.text-view.im-module}im-module. Type: @code{string}. Accessor: @anchor{fn.text-view-im-module}@code{text-view-im-module}.
@item @anchor{slot.text-view.indent}indent. Type: @code{integer}. Accessor: @anchor{fn.text-view-indent}@code{text-view-indent}.
@item @anchor{slot.text-view.justification}justification. Type: @ref{justification}. Accessor: @anchor{fn.text-view-justification}@code{text-view-justification}.
@item @anchor{slot.text-view.left-margin}left-margin. Type: @code{integer}. Accessor: @anchor{fn.text-view-left-margin}@code{text-view-left-margin}.
@item @anchor{slot.text-view.overwrite}overwrite. Type: @code{boolean}. Accessor: @anchor{fn.text-view-overwrite}@code{text-view-overwrite}.
@item @anchor{slot.text-view.pixels-above-lines}pixels-above-lines. Type: @code{integer}. Accessor: @anchor{fn.text-view-pixels-above-lines}@code{text-view-pixels-above-lines}.
@item @anchor{slot.text-view.pixels-below-lines}pixels-below-lines. Type: @code{integer}. Accessor: @anchor{fn.text-view-pixels-below-lines}@code{text-view-pixels-below-lines}.
@item @anchor{slot.text-view.pixels-inside-wrap}pixels-inside-wrap. Type: @code{integer}. Accessor: @anchor{fn.text-view-pixels-inside-wrap}@code{text-view-pixels-inside-wrap}.
@item @anchor{slot.text-view.right-margin}right-margin. Type: @code{integer}. Accessor: @anchor{fn.text-view-right-margin}@code{text-view-right-margin}.
@item @anchor{slot.text-view.tabs}tabs. Type: @code{PangoTabArray}. Accessor: @anchor{fn.text-view-tabs}@code{text-view-tabs}.
@item @anchor{slot.text-view.wrap-mode}wrap-mode. Type: @ref{wrap-mode}. Accessor: @anchor{fn.text-view-wrap-mode}@code{text-view-wrap-mode}.
@end itemize


Signals:
@itemize
@item @anchor{signal.text-view.backspace}"backspace". Signature: (instance @ref{text-view}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.copy-clipboard}"copy-clipboard". Signature: (instance @ref{text-view}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.cut-clipboard}"cut-clipboard". Signature: (instance @ref{text-view}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.delete-from-cursor}"delete-from-cursor". Signature: (instance @ref{text-view}), (arg-1 @ref{delete-type}), (arg-2 @code{integer}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.insert-at-cursor}"insert-at-cursor". Signature: (instance @ref{text-view}), (arg-1 @code{string}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.move-cursor}"move-cursor". Signature: (instance @ref{text-view}), (arg-1 @ref{movement-step}), (arg-2 @code{integer}), (arg-3 @code{boolean}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.move-viewport}"move-viewport". Signature: (instance @ref{text-view}), (arg-1 @ref{scroll-step}), (arg-2 @code{integer}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.page-horizontally}"page-horizontally". Signature: (instance @ref{text-view}), (arg-1 @code{integer}), (arg-2 @code{boolean}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.paste-clipboard}"paste-clipboard". Signature: (instance @ref{text-view}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.populate-popup}"populate-popup". Signature: (instance @ref{text-view}), (arg-1 @ref{menu}) @result{} void. Options: run-last.
@item @anchor{signal.text-view.select-all}"select-all". Signature: (instance @ref{text-view}), (arg-1 @code{boolean}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.set-anchor}"set-anchor". Signature: (instance @ref{text-view}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.set-scroll-adjustments}"set-scroll-adjustments". Signature: (instance @ref{text-view}), (arg-1 @ref{adjustment}), (arg-2 @ref{adjustment}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.toggle-cursor-visible}"toggle-cursor-visible". Signature: (instance @ref{text-view}) @result{} void. Options: run-last, action.
@item @anchor{signal.text-view.toggle-overwrite}"toggle-overwrite". Signature: (instance @ref{text-view}) @result{} void. Options: run-last, action.
@end itemize




@node toggle-button
@section toggle-button
@Class toggle-button
Superclass: @ref{button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Subclasses: @ref{check-button}

A @ref{toggle-button} is a @ref{button} which will remain 'pressed-in' when clicked. Clicking again will cause the toggle button to return to its normal state.

The state of a @ref{toggle-button} is stored in @SlotRef{toggle-button,active} and @SlotRef{toggle-button,inconsistent}.

Slots:
@itemize
@item @anchor{slot.toggle-button.active}active. Type: @code{boolean}. Accessor: @anchor{fn.toggle-button-active}@code{toggle-button-active}.

If the toggle button should be pressed in or not.

Default value: False
@item @anchor{slot.toggle-button.draw-indicator}draw-indicator. Type: @code{boolean}. Accessor: @anchor{fn.toggle-button-draw-indicator}@code{toggle-button-draw-indicator}.

If the toggle part of the button is displayed.

Default value: False
@item @anchor{slot.toggle-button.inconsistent}inconsistent. Type: @code{boolean}. Accessor: @anchor{fn.toggle-button-inconsistent}@code{toggle-button-inconsistent}.

If the toggle button is in an "in between" state.

Default value: False
@end itemize


Signals:
@itemize
@item @anchor{signal.toggle-button.toggled}"toggled". Signature: (instance @ref{toggle-button}) @result{} void. Options: run-first.

Should be connected if you wish to perform an action whenever the @ref{toggle-button}'s state is changed.
@end itemize




@node toggle-tool-button
@section toggle-tool-button
@Class toggle-tool-button
Superclass: @ref{tool-button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Subclasses: @ref{radio-tool-button}

Slots:
@itemize
@item @anchor{slot.toggle-tool-button.active}active. Type: @code{boolean}. Accessor: @anchor{fn.toggle-tool-button-active}@code{toggle-tool-button-active}.
@end itemize


Signals:
@itemize
@item @anchor{signal.toggle-tool-button.toggled}"toggled". Signature: (instance @ref{toggle-tool-button}) @result{} void. Options: run-first.
@end itemize




@node tool-button
@section tool-button
@Class tool-button
Superclass: @ref{tool-item} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Subclasses: @ref{toggle-tool-button} @ref{menu-tool-button}

Slots:
@itemize
@item @anchor{slot.tool-button.icon-name}icon-name. Type: @code{string}. Accessor: @anchor{fn.tool-button-icon-name}@code{tool-button-icon-name}.
@item @anchor{slot.tool-button.icon-widget}icon-widget. Type: @ref{widget}. Accessor: @anchor{fn.tool-button-icon-widget}@code{tool-button-icon-widget}.
@item @anchor{slot.tool-button.label}label. Type: @code{string}. Accessor: @anchor{fn.tool-button-label}@code{tool-button-label}.
@item @anchor{slot.tool-button.label-widget}label-widget. Type: @ref{widget}. Accessor: @anchor{fn.tool-button-label-widget}@code{tool-button-label-widget}.
@item @anchor{slot.tool-button.stock-id}stock-id. Type: @code{string}. Accessor: @anchor{fn.tool-button-stock-id}@code{tool-button-stock-id}.
@item @anchor{slot.tool-button.use-underline}use-underline. Type: @code{boolean}. Accessor: @anchor{fn.tool-button-use-underline}@code{tool-button-use-underline}.
@end itemize


Signals:
@itemize
@item @anchor{signal.tool-button.clicked}"clicked". Signature: (instance @ref{tool-button}) @result{} void. Options: run-first, action.
@end itemize




@node tool-item
@section tool-item
@Class tool-item
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable}

Subclasses: @ref{separator-tool-item} @ref{tool-button}

Slots:
@itemize
@item @anchor{slot.tool-item.expand}expand. Type: @code{boolean}. Accessor: @anchor{fn.tool-item-expand}@code{tool-item-expand}.
@item @anchor{slot.tool-item.icon-size}icon-size. Type: @ref{icon-size}. Accessor: @anchor{fn.tool-item-icon-size}@code{tool-item-icon-size}. Read-only.
@item @anchor{slot.tool-item.is-important}is-important. Type: @code{boolean}. Accessor: @anchor{fn.tool-item-is-important}@code{tool-item-is-important}.
@item @anchor{slot.tool-item.orientation}orientation. Type: @ref{orientation}. Accessor: @anchor{fn.tool-item-orientation}@code{tool-item-orientation}. Read-only.
@item @anchor{slot.tool-item.relief-style}relief-style. Type: @ref{relief-style}. Accessor: @anchor{fn.tool-item-relief-style}@code{tool-item-relief-style}. Read-only.
@item @anchor{slot.tool-item.toolbar-style}toolbar-style. Type: @ref{toolbar-style}. Accessor: @anchor{fn.tool-item-toolbar-style}@code{tool-item-toolbar-style}. Read-only.
@item @anchor{slot.tool-item.use-drag-window}use-drag-window. Type: @code{boolean}. Accessor: @anchor{fn.tool-item-use-drag-window}@code{tool-item-use-drag-window}.
@item @anchor{slot.tool-item.visible-horizontal}visible-horizontal. Type: @code{boolean}. Accessor: @anchor{fn.tool-item-visible-horizontal}@code{tool-item-visible-horizontal}.
@item @anchor{slot.tool-item.visible-vertical}visible-vertical. Type: @code{boolean}. Accessor: @anchor{fn.tool-item-visible-vertical}@code{tool-item-visible-vertical}.
@end itemize


Signals:
@itemize
@item @anchor{signal.tool-item.create-menu-proxy}"create-menu-proxy". Signature: (instance @ref{tool-item}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.tool-item.set-tooltip}"set-tooltip". Signature: (instance @ref{tool-item}), (arg-1 @code{tooltips}), (arg-2 @code{string}), (arg-3 @code{string}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.tool-item.toolbar-reconfigured}"toolbar-reconfigured". Signature: (instance @ref{tool-item}) @result{} void. Options: run-last.
@end itemize




@node toolbar
@section toolbar
@Class toolbar
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable} @ref{tool-shell}

Slots:
@itemize
@item @anchor{slot.toolbar.icon-size}icon-size. Type: @code{integer}. Accessor: @anchor{fn.toolbar-icon-size}@code{toolbar-icon-size}.
@item @anchor{slot.toolbar.icon-size-set}icon-size-set. Type: @code{boolean}. Accessor: @anchor{fn.toolbar-icon-size-set}@code{toolbar-icon-size-set}.
@item @anchor{slot.toolbar.show-arrow}show-arrow. Type: @code{boolean}. Accessor: @anchor{fn.toolbar-show-arrow}@code{toolbar-show-arrow}.
@item @anchor{slot.toolbar.toolbar-style}toolbar-style. Type: @ref{toolbar-style}. Accessor: @anchor{fn.toolbar-toolbar-style}@code{toolbar-toolbar-style}.
@item @anchor{slot.toolbar.tooltips}tooltips. Type: @code{boolean}. Accessor: @anchor{fn.toolbar-tooltips}@code{toolbar-tooltips}.
@end itemize


Signals:
@itemize
@item @anchor{signal.toolbar.focus-home-or-end}"focus-home-or-end". Signature: (instance @ref{toolbar}), (arg-1 @code{boolean}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.toolbar.orientation-changed}"orientation-changed". Signature: (instance @ref{toolbar}), (arg-1 @ref{orientation}) @result{} void. Options: run-first.
@item @anchor{signal.toolbar.popup-context-menu}"popup-context-menu". Signature: (instance @ref{toolbar}), (arg-1 @code{integer}), (arg-2 @code{integer}), (arg-3 @code{integer}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.toolbar.style-changed}"style-changed". Signature: (instance @ref{toolbar}), (arg-1 @ref{toolbar-style}) @result{} void. Options: run-first.
@end itemize




@node tree-view
@section tree-view
@Class tree-view
Superclass: @ref{container} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.tree-view.bin-window}bin-window. Type: @ref{g-object}. Accessor: @anchor{fn.tree-view-bin-window}@code{tree-view-bin-window}. Read-only.
@item @anchor{slot.tree-view.column-drag-function}column-drag-function. Type: ????. Accessor: @anchor{fn.tree-view-column-drag-function}@code{tree-view-column-drag-function}. Write-only.
@item @anchor{slot.tree-view.enable-grid-lines}enable-grid-lines. Type: @ref{tree-view-grid-lines}. Accessor: @anchor{fn.tree-view-enable-grid-lines}@code{tree-view-enable-grid-lines}.
@item @anchor{slot.tree-view.enable-search}enable-search. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-enable-search}@code{tree-view-enable-search}.
@item @anchor{slot.tree-view.enable-tree-lines}enable-tree-lines. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-enable-tree-lines}@code{tree-view-enable-tree-lines}.
@item @anchor{slot.tree-view.expander-column}expander-column. Type: @ref{tree-view-column}. Accessor: @anchor{fn.tree-view-expander-column}@code{tree-view-expander-column}.
@item @anchor{slot.tree-view.fixed-height-mode}fixed-height-mode. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-fixed-height-mode}@code{tree-view-fixed-height-mode}.
@item @anchor{slot.tree-view.hadjustment}hadjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.tree-view-hadjustment}@code{tree-view-hadjustment}.
@item @anchor{slot.tree-view.headers-clickable}headers-clickable. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-headers-clickable}@code{tree-view-headers-clickable}.
@item @anchor{slot.tree-view.headers-visible}headers-visible. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-headers-visible}@code{tree-view-headers-visible}.
@item @anchor{slot.tree-view.hover-expand}hover-expand. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-hover-expand}@code{tree-view-hover-expand}.
@item @anchor{slot.tree-view.hover-selection}hover-selection. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-hover-selection}@code{tree-view-hover-selection}.
@item @anchor{slot.tree-view.level-indentation}level-indentation. Type: @code{integer}. Accessor: @anchor{fn.tree-view-level-indentation}@code{tree-view-level-indentation}.
@item @anchor{slot.tree-view.model}model. Type: @ref{tree-model}. Accessor: @anchor{fn.tree-view-model}@code{tree-view-model}.
@item @anchor{slot.tree-view.reorderable}reorderable. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-reorderable}@code{tree-view-reorderable}.
@item @anchor{slot.tree-view.row-separator-func}row-separator-func. Type: ????. Accessor: @anchor{fn.tree-view-row-separator-func}@code{tree-view-row-separator-func}. Write-only.
@item @anchor{slot.tree-view.rubber-banding}rubber-banding. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-rubber-banding}@code{tree-view-rubber-banding}.
@item @anchor{slot.tree-view.rules-hint}rules-hint. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-rules-hint}@code{tree-view-rules-hint}.
@item @anchor{slot.tree-view.search-column}search-column. Type: @code{integer}. Accessor: @anchor{fn.tree-view-search-column}@code{tree-view-search-column}.
@item @anchor{slot.tree-view.search-entry}search-entry. Type: @ref{g-object}. Accessor: @anchor{fn.tree-view-search-entry}@code{tree-view-search-entry}.
@item @anchor{slot.tree-view.search-equal-func}search-equal-func. Type: ????. Accessor: @anchor{fn.tree-view-search-equal-func}@code{tree-view-search-equal-func}. Write-only.
@item @anchor{slot.tree-view.search-position-func}search-position-func. Type: ????. Accessor: @anchor{fn.tree-view-search-position-func}@code{tree-view-search-position-func}. Write-only.
@item @anchor{slot.tree-view.selection}selection. Type: @ref{g-object}. Accessor: @anchor{fn.tree-view-selection}@code{tree-view-selection}. Read-only.
@item @anchor{slot.tree-view.show-expanders}show-expanders. Type: @code{boolean}. Accessor: @anchor{fn.tree-view-show-expanders}@code{tree-view-show-expanders}.
@item @anchor{slot.tree-view.tooltip-column}tooltip-column. Type: @code{integer}. Accessor: @anchor{fn.tree-view-tooltip-column}@code{tree-view-tooltip-column}.
@item @anchor{slot.tree-view.vadjustment}vadjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.tree-view-vadjustment}@code{tree-view-vadjustment}.
@end itemize


Signals:
@itemize
@item @anchor{signal.tree-view.columns-changed}"columns-changed". Signature: (instance @ref{tree-view}) @result{} void. Options: run-last.
@item @anchor{signal.tree-view.cursor-changed}"cursor-changed". Signature: (instance @ref{tree-view}) @result{} void. Options: run-last.
@item @anchor{signal.tree-view.expand-collapse-cursor-row}"expand-collapse-cursor-row". Signature: (instance @ref{tree-view}), (arg-1 @code{boolean}), (arg-2 @code{boolean}), (arg-3 @code{boolean}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.tree-view.move-cursor}"move-cursor". Signature: (instance @ref{tree-view}), (arg-1 @ref{movement-step}), (arg-2 @code{integer}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.tree-view.row-activated}"row-activated". Signature: (instance @ref{tree-view}), (arg-1 @ref{tree-path}), (arg-2 @ref{tree-view-column}) @result{} void. Options: run-last, action.
@item @anchor{signal.tree-view.row-collapsed}"row-collapsed". Signature: (instance @ref{tree-view}), (arg-1 @ref{tree-iter}), (arg-2 @ref{tree-path}) @result{} void. Options: run-last.
@item @anchor{signal.tree-view.row-expanded}"row-expanded". Signature: (instance @ref{tree-view}), (arg-1 @ref{tree-iter}), (arg-2 @ref{tree-path}) @result{} void. Options: run-last.
@item @anchor{signal.tree-view.select-all}"select-all". Signature: (instance @ref{tree-view}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.tree-view.select-cursor-parent}"select-cursor-parent". Signature: (instance @ref{tree-view}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.tree-view.select-cursor-row}"select-cursor-row". Signature: (instance @ref{tree-view}), (arg-1 @code{boolean}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.tree-view.set-scroll-adjustments}"set-scroll-adjustments". Signature: (instance @ref{tree-view}), (arg-1 @ref{adjustment}), (arg-2 @ref{adjustment}) @result{} void. Options: run-last, action.
@item @anchor{signal.tree-view.start-interactive-search}"start-interactive-search". Signature: (instance @ref{tree-view}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.tree-view.test-collapse-row}"test-collapse-row". Signature: (instance @ref{tree-view}), (arg-1 @ref{tree-iter}), (arg-2 @ref{tree-path}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.tree-view.test-expand-row}"test-expand-row". Signature: (instance @ref{tree-view}), (arg-1 @ref{tree-iter}), (arg-2 @ref{tree-path}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.tree-view.toggle-cursor-row}"toggle-cursor-row". Signature: (instance @ref{tree-view}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.tree-view.unselect-all}"unselect-all". Signature: (instance @ref{tree-view}) @result{} @code{boolean}. Options: run-last, action.
@end itemize




@node v-box
@section v-box
@Class v-box
Superclass: @ref{box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Subclasses: @ref{recent-chooser-widget} @ref{gamma-curve} @ref{font-selection} @ref{file-chooser-widget} @ref{color-selection}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node v-button-box
@section v-button-box
@Class v-button-box
Superclass: @ref{button-box} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node v-paned
@section v-paned
@Class v-paned
Superclass: @ref{paned} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node v-ruler
@section v-ruler
@Class v-ruler
Superclass: @ref{ruler} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node v-scale
@section v-scale
@Class v-scale
Superclass: @ref{scale} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

The @ref{v-scale} widget is used to allow the user to select a value using a vertical slider.

The position to show the current value, and the number of decimal places shown can be set using the parent @ref{scale} class's functions.

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node v-scrollbar
@section v-scrollbar
@Class v-scrollbar
Superclass: @ref{scrollbar} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node v-separator
@section v-separator
@Class v-separator
Superclass: @ref{separator} @ref{atk-implementor-iface} @ref{buildable} @ref{orientable}

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node viewport
@section viewport
@Class viewport
Superclass: @ref{bin} @ref{atk-implementor-iface} @ref{buildable}

Slots:
@itemize
@item @anchor{slot.viewport.hadjustment}hadjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.viewport-hadjustment}@code{viewport-hadjustment}.
@item @anchor{slot.viewport.shadow-type}shadow-type. Type: @ref{shadow-type}. Accessor: @anchor{fn.viewport-shadow-type}@code{viewport-shadow-type}.
@item @anchor{slot.viewport.vadjustment}vadjustment. Type: @ref{adjustment}. Accessor: @anchor{fn.viewport-vadjustment}@code{viewport-vadjustment}.
@end itemize


Signals:
@itemize
@item @anchor{signal.viewport.set-scroll-adjustments}"set-scroll-adjustments". Signature: (instance @ref{viewport}), (arg-1 @ref{adjustment}), (arg-2 @ref{adjustment}) @result{} void. Options: run-last, action.
@end itemize




@node volume-button
@section volume-button
@Class volume-button
Superclass: @ref{scale-button} @ref{atk-implementor-iface} @ref{activatable} @ref{buildable} @ref{orientable}

@ref{volume-button} is a subclass of @ref{scale-button} that has been tailored for use as a volume control widget with suitable icons, tooltips and accessible labels.

Slots:
@itemize
@end itemize


Signals:
@itemize
@end itemize




@node widget
@section widget
@Class widget
Superclass: @ref{gtk-object} @ref{atk-implementor-iface} @ref{buildable}

Subclasses: @ref{separator} @ref{ruler} @ref{range} @ref{progress} @ref{misc} @ref{invisible} @ref{h-s-v} @ref{entry} @ref{drawing-area} @ref{container} @ref{cell-view} @ref{calendar}

Slots:
@itemize
@item @anchor{slot.widget.accessible}accessible. Type: @ref{g-object}. Accessor: @anchor{fn.widget-accessible}@code{widget-accessible}. Read-only.
@item @anchor{slot.widget.app-paintable}app-paintable. Type: @code{boolean}. Accessor: @anchor{fn.widget-app-paintable}@code{widget-app-paintable}.
@item @anchor{slot.widget.can-default}can-default. Type: @code{boolean}. Accessor: @anchor{fn.widget-can-default}@code{widget-can-default}.
@item @anchor{slot.widget.can-focus}can-focus. Type: @code{boolean}. Accessor: @anchor{fn.widget-can-focus}@code{widget-can-focus}.
@item @anchor{slot.widget.child-visible}child-visible. Type: @code{boolean}. Accessor: @anchor{fn.widget-child-visible}@code{widget-child-visible}.
@item @anchor{slot.widget.colormap}colormap. Type: @ref{gdk-colormap}. Accessor: @anchor{fn.widget-colormap}@code{widget-colormap}.
@item @anchor{slot.widget.composite-child}composite-child. Type: @code{boolean}. Accessor: @anchor{fn.widget-composite-child}@code{widget-composite-child}. Read-only.
@item @anchor{slot.widget.composite-name}composite-name. Type: @code{string}. Accessor: @anchor{fn.widget-composite-name}@code{widget-composite-name}.
@item @anchor{slot.widget.direction}direction. Type: @ref{text-direction}. Accessor: @anchor{fn.widget-direction}@code{widget-direction}.
@item @anchor{slot.widget.events}events. Type: @ref{event-mask}. Accessor: @anchor{fn.widget-events}@code{widget-events}.
@item @anchor{slot.widget.extension-events}extension-events. Type: @ref{gdk-extension-mode}. Accessor: @anchor{fn.widget-extension-events}@code{widget-extension-events}.
@item @anchor{slot.widget.has-default}has-default. Type: @code{boolean}. Accessor: @anchor{fn.widget-has-default}@code{widget-has-default}.
@item @anchor{slot.widget.has-focus}has-focus. Type: @code{boolean}. Accessor: @anchor{fn.widget-has-focus}@code{widget-has-focus}.
@item @anchor{slot.widget.has-tooltip}has-tooltip. Type: @code{boolean}. Accessor: @anchor{fn.widget-has-tooltip}@code{widget-has-tooltip}.
@item @anchor{slot.widget.height-request}height-request. Type: @code{integer}. Accessor: @anchor{fn.widget-height-request}@code{widget-height-request}.
@item @anchor{slot.widget.is-focus}is-focus. Type: @code{boolean}. Accessor: @anchor{fn.widget-is-focus}@code{widget-is-focus}.
@item @anchor{slot.widget.modifier-style}modifier-style. Type: @ref{rc-style}. Accessor: @anchor{fn.widget-modifier-style}@code{widget-modifier-style}.
@item @anchor{slot.widget.name}name. Type: @code{string}. Accessor: @anchor{fn.widget-name}@code{widget-name}.
@item @anchor{slot.widget.no-show-all}no-show-all. Type: @code{boolean}. Accessor: @anchor{fn.widget-no-show-all}@code{widget-no-show-all}.
@item @anchor{slot.widget.pango-context}pango-context. Type: @ref{g-object}. Accessor: @anchor{fn.widget-pango-context}@code{widget-pango-context}. Read-only.
@item @anchor{slot.widget.parent}parent. Type: @ref{container}. Accessor: @anchor{fn.widget-parent}@code{widget-parent}.
@item @anchor{slot.widget.parent-window}parent-window. Type: @ref{gdk-window}. Accessor: @anchor{fn.widget-parent-window}@code{widget-parent-window}.
@item @anchor{slot.widget.receives-default}receives-default. Type: @code{boolean}. Accessor: @anchor{fn.widget-receives-default}@code{widget-receives-default}.
@item @anchor{slot.widget.redraw-on-allocate}redraw-on-allocate. Type: @code{boolean}. Accessor: @anchor{fn.widget-redraw-on-allocate}@code{widget-redraw-on-allocate}. Write-only.
@item @anchor{slot.widget.sensitive}sensitive. Type: @code{boolean}. Accessor: @anchor{fn.widget-sensitive}@code{widget-sensitive}.
@item @anchor{slot.widget.style}style. Type: @ref{style}. Accessor: @anchor{fn.widget-style}@code{widget-style}.
@item @anchor{slot.widget.tooltip-markup}tooltip-markup. Type: @code{string}. Accessor: @anchor{fn.widget-tooltip-markup}@code{widget-tooltip-markup}.
@item @anchor{slot.widget.tooltip-text}tooltip-text. Type: @code{string}. Accessor: @anchor{fn.widget-tooltip-text}@code{widget-tooltip-text}.
@item @anchor{slot.widget.tooltip-window}tooltip-window. Type: @ref{g-object}. Accessor: @anchor{fn.widget-tooltip-window}@code{widget-tooltip-window}.
@item @anchor{slot.widget.toplevel}toplevel. Type: @ref{widget}. Accessor: @anchor{fn.widget-toplevel}@code{widget-toplevel}. Read-only.
@item @anchor{slot.widget.visible}visible. Type: @code{boolean}. Accessor: @anchor{fn.widget-visible}@code{widget-visible}.
@item @anchor{slot.widget.visual}visual. Type: @ref{visual}. Accessor: @anchor{fn.widget-visual}@code{widget-visual}. Read-only.
@item @anchor{slot.widget.width-request}width-request. Type: @code{integer}. Accessor: @anchor{fn.widget-width-request}@code{widget-width-request}.
@item @anchor{slot.widget.window}window. Type: @ref{gdk-window}. Accessor: @anchor{fn.widget-window}@code{widget-window}. Read-only.
@end itemize


Signals:
@itemize
@item @anchor{signal.widget.accel-closures-changed}\"accel-closures-changed\". Signature: (instance @ref{widget}) @result{} void. Options: .
@item @anchor{signal.widget.button-press-event}\"button-press-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.button-release-event}\"button-release-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.can-activate-accel}\"can-activate-accel\". Signature: (instance @ref{widget}), (arg-1 @code{integer}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.child-notify}\"child-notify\". Signature: (instance @ref{widget}), (arg-1 GParam) @result{} void. Options: run-first, no-recurse, detailed, no-hooks.
@item @anchor{signal.widget.client-event}\"client-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.composited-changed}\"composited-changed\". Signature: (instance @ref{widget}) @result{} void. Options: run-last, action.
@item @anchor{signal.widget.configure-event}\"configure-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.damage-event}\"damage-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.delete-event}\"delete-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.destroy-event}\"destroy-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.direction-changed}\"direction-changed\". Signature: (instance @ref{widget}), (arg-1 @ref{text-direction}) @result{} void. Options: run-first.
@item @anchor{signal.widget.drag-begin}\"drag-begin\". Signature: (instance @ref{widget}), (arg-1 @ref{drag-context}) @result{} void. Options: run-last.
@item @anchor{signal.widget.drag-data-delete}\"drag-data-delete\". Signature: (instance @ref{widget}), (arg-1 @ref{drag-context}) @result{} void. Options: run-last.
@item @anchor{signal.widget.drag-data-get}\"drag-data-get\". Signature: (instance @ref{widget}), (arg-1 @ref{drag-context}), (arg-2 @code{GtkSelectionData}), (arg-3 @code{integer}), (arg-4 @code{integer}) @result{} void. Options: run-last.
@item @anchor{signal.widget.drag-data-received}\"drag-data-received\". Signature: (instance @ref{widget}), (arg-1 @ref{drag-context}), (arg-2 @code{integer}), (arg-3 @code{integer}), (arg-4 @code{GtkSelectionData}), (arg-5 @code{integer}), (arg-6 @code{integer}) @result{} void. Options: run-last.
@item @anchor{signal.widget.drag-drop}\"drag-drop\". Signature: (instance @ref{widget}), (arg-1 @ref{drag-context}), (arg-2 @code{integer}), (arg-3 @code{integer}), (arg-4 @code{integer}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.drag-end}\"drag-end\". Signature: (instance @ref{widget}), (arg-1 @ref{drag-context}) @result{} void. Options: run-last.
@item @anchor{signal.widget.drag-failed}\"drag-failed\". Signature: (instance @ref{widget}), (arg-1 @ref{drag-context}), (arg-2 @ref{drag-result}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.drag-leave}\"drag-leave\". Signature: (instance @ref{widget}), (arg-1 @ref{drag-context}), (arg-2 @code{integer}) @result{} void. Options: run-last.
@item @anchor{signal.widget.drag-motion}\"drag-motion\". Signature: (instance @ref{widget}), (arg-1 @ref{drag-context}), (arg-2 @code{integer}), (arg-3 @code{integer}), (arg-4 @code{integer}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.enter-notify-event}\"enter-notify-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.event}\"event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.event-after}\"event-after\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} void. Options: .
@item @anchor{signal.widget.expose-event}\"expose-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.focus}\"focus\". Signature: (instance @ref{widget}), (arg-1 @ref{direction-type}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.focus-in-event}\"focus-in-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.focus-out-event}\"focus-out-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.grab-broken-event}\"grab-broken-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.grab-focus}\"grab-focus\". Signature: (instance @ref{widget}) @result{} void. Options: run-last, action.
@item @anchor{signal.widget.grab-notify}\"grab-notify\". Signature: (instance @ref{widget}), (arg-1 @code{boolean}) @result{} void. Options: run-first.
@item @anchor{signal.widget.hide}\"hide\". Signature: (instance @ref{widget}) @result{} void. Options: run-first.
@item @anchor{signal.widget.hierarchy-changed}\"hierarchy-changed\". Signature: (instance @ref{widget}), (arg-1 @ref{widget}) @result{} void. Options: run-last.
@item @anchor{signal.widget.key-press-event}\"key-press-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.key-release-event}\"key-release-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.keynav-failed}\"keynav-failed\". Signature: (instance @ref{widget}), (arg-1 @ref{direction-type}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.leave-notify-event}\"leave-notify-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.map}\"map\". Signature: (instance @ref{widget}) @result{} void. Options: run-first.
@item @anchor{signal.widget.map-event}\"map-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.mnemonic-activate}\"mnemonic-activate\". Signature: (instance @ref{widget}), (arg-1 @code{boolean}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.motion-notify-event}\"motion-notify-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.move-focus}\"move-focus\". Signature: (instance @ref{widget}), (arg-1 @ref{direction-type}) @result{} void. Options: run-last, action.
@item @anchor{signal.widget.no-expose-event}\"no-expose-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.parent-set}\"parent-set\". Signature: (instance @ref{widget}), (arg-1 @ref{widget}) @result{} void. Options: run-first.
@item @anchor{signal.widget.popup-menu}\"popup-menu\". Signature: (instance @ref{widget}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.widget.property-notify-event}\"property-notify-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.proximity-in-event}\"proximity-in-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.proximity-out-event}\"proximity-out-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.query-tooltip}\"query-tooltip\". Signature: (instance @ref{widget}), (arg-1 @code{integer}), (arg-2 @code{integer}), (arg-3 @code{boolean}), (arg-4 @ref{tooltip}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.realize}\"realize\". Signature: (instance @ref{widget}) @result{} void. Options: run-first.
@item @anchor{signal.widget.screen-changed}\"screen-changed\". Signature: (instance @ref{widget}), (arg-1 @ref{screen}) @result{} void. Options: run-last.
@item @anchor{signal.widget.scroll-event}\"scroll-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.selection-clear-event}\"selection-clear-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.selection-get}\"selection-get\". Signature: (instance @ref{widget}), (arg-1 @code{GtkSelectionData}), (arg-2 @code{integer}), (arg-3 @code{integer}) @result{} void. Options: run-last.
@item @anchor{signal.widget.selection-notify-event}\"selection-notify-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.selection-received}\"selection-received\". Signature: (instance @ref{widget}), (arg-1 @code{GtkSelectionData}), (arg-2 @code{integer}) @result{} void. Options: run-last.
@item @anchor{signal.widget.selection-request-event}\"selection-request-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.show}\"show\". Signature: (instance @ref{widget}) @result{} void. Options: run-first.
@item @anchor{signal.widget.show-help}\"show-help\". Signature: (instance @ref{widget}), (arg-1 @ref{widget-help-type}) @result{} @code{boolean}. Options: run-last, action.
@item @anchor{signal.widget.size-allocate}\"size-allocate\". Signature: (instance @ref{widget}), (arg-1 @ref{rectangle}) @result{} void. Options: run-first.
@item @anchor{signal.widget.size-request}\"size-request\". Signature: (instance @ref{widget}), (arg-1 @code{GtkRequisition}) @result{} void. Options: run-first.
@item @anchor{signal.widget.state-changed}\"state-changed\". Signature: (instance @ref{widget}), (arg-1 @ref{state-type}) @result{} void. Options: run-first.
@item @anchor{signal.widget.style-set}\"style-set\". Signature: (instance @ref{widget}), (arg-1 @ref{style}) @result{} void. Options: run-first.
@item @anchor{signal.widget.unmap}\"unmap\". Signature: (instance @ref{widget}) @result{} void. Options: run-first.
@item @anchor{signal.widget.unmap-event}\"unmap-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.unrealize}\"unrealize\". Signature: (instance @ref{widget}) @result{} void. Options: run-last.
@item @anchor{signal.widget.visibility-notify-event}\"visibility-notify-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@item @anchor{signal.widget.window-state-event}\"window-state-event\". Signature: (instance @ref{widget}), (arg-1 @ref{event}) @result{} @code{boolean}. Options: run-last.
@end itemize


@RMethod widget-show

Undocumented yet

@RMethod widget-grab-focus

Undocumented yet

